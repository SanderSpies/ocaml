(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                             Sander Spies                               *)
(*                                                                        *)
(*   Copyright 2017 - 2018                                                *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* From C-- to WebAssembly object file AST *)

open Cmm
open Ast
open Values
open Wasm_types

(*
  WebAssembly (wasm) is a secure stackmachine. It guarantees security by using 
  type safety for all variables, limiting memory access, and having no access 
  to the stack. 
  
  It's possible to hack around not having stack access, but it's probably wiser 
  to wait for the right additions in wasm to appear. Luckily this already being 
  worked on:
  - https://github.com/WebAssembly/exception-handling/blob/master/proposals/Level-1.md
  - https://github.com/WebAssembly/gc/pull/34 
  - https://github.com/WebAssembly/tail-call/blob/master/proposals/tail-call/Overview.md 

  The code is compiled to the wasm object file format, which is defined here: 
  https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md. This
  is required to be able to use LLVM's LLD to link the generated wasm binary 
  with other code that's compiled to wasm (from clang for example).
*)

module VarMap = Map.Make(String)

type local_space = {mutable l_map : (int32 * value_type) VarMap.t; mutable l_count : int32}

type block_stack = string Stack.t

(* the resulting wasm module *)
let wasm_module = ref {
  types = [];
  globals = [];
  tables = Types.[{
    ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
  }];
  memories = Types.[{
    (* TODO: this needs to be improved when doing GC *)
    mtype = MemoryType {min = 100l; max = Some 100l}
  }];
  funcs = [];
  start = None;
  elems = [];
  data = [];
  imports = [];
  exports = [];
  symbols = [];
}

let empty_locals () = {l_map = VarMap.empty; l_count = 0l};

type context =
  { locals : local_space }

let empty_context () =
  { locals = empty_locals() }

let block_stack : block_stack = Stack.create ()

let lookup_local space x =
  VarMap.find x space.l_map

let local (c : context) x = lookup_local c.locals x

let context = ref (empty_context ())

let bind_local (space:local_space) x value_type =
  if VarMap.mem x space.l_map then
    failwith ("Duplicate:" ^ x);
  let i = space.l_count in
  space.l_map <- VarMap.add x (space.l_count, value_type) space.l_map;
  space.l_count <- Int32.add space.l_count 1l;
  if space.l_count = 0l then
    failwith "Too many bindings";
  i

let func_symbol_exists symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import _ when name = symbol -> true
    | Function _ when name = symbol -> true        
    | _ -> false
  ) w.symbols

let create_func_symbol name mt = (* TODO: move to encode *)
  let w = !wasm_module in
  wasm_module := {w with 
    symbols = w.symbols @ [{
      name = name;
      details = Function mt
    }]
  }

let create_import_symbol name mt =
  let w = !wasm_module in
  wasm_module := {w with 
    symbols = w.symbols @ [{
      name = name;
      details = Import mt
    }]
  }

let create_symbol_table () = ( (* TODO: move to encode *)
  let w = !wasm_module in
  let global_symbols = (List.mapi (fun i (g:Ast.global) -> 
    {
    name = g.name;
    details = Global ({
      index = Int32.of_int i;      
    })
  }) w.globals)
  in
  wasm_module := {w with
    symbols =
      w.symbols @ global_symbols 
  }
)

let bind_local (c : context) name value_type = bind_local c.locals name value_type

let current_return_type = ref []

let enter_func () = (
  current_return_type := [];
  {locals = empty_locals()}
)

let unique_name_counter = ref 0

let name s =
  try Utf8.decode s with Utf8.Utf8 ->
    failwith "invalid UTF-8 encoding"

let global_offset = ref 0

let end_assembly () = (  
  create_symbol_table (); (* Move to Encode *)
  Encode.encode !wasm_module;  
  wasm_module := {
    types = [];
    globals = [];
    tables = Types.[{
      ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
    }];
    memories = Types.[{
      (* TODO: this needs to be improved when doing GC *)
      mtype = MemoryType {min = 100l; max = Some 100l}
    }];
    funcs = [];
    start = None;
    elems = [];
    data = [];
    imports = [];
    exports = [];
    symbols = []; (* Move to Encode *)
  };
  context := empty_context ();
  current_return_type := [];  
)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(_s, ty, _alloc, _) -> ty
  | Cload (c, _) ->
      begin match c with
      | Word_val -> typ_val
      | Single | Double | Double_u -> typ_float
      | _ -> typ_int
      end
  | Calloc -> typ_val
  | Cstore (_c, _) -> typ_void
  | Caddi | Csubi | Cmuli | Cmulhi | Cdivi | Cmodi |
    Cand | Cor | Cxor | Clsl | Clsr | Casr |
    Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Caddv -> typ_val
  | Cadda -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise _ -> typ_void
| Ccheckbound -> typ_void

let convert_result = function 
   | [||] -> []   
   | [|Float|] -> [F32Type]   
   | [|Val|]
   | [|Addr|]
   | [|Int|] -> [I32Type]
   | _ -> assert false

(*
  FIXME: Exceptions are completely broken at the moment!

  exceptions are tricky for now as wasm doesn't support it.

  Right now it works as follows:
  - within JS we raise and catch exceptions
  - the tryWith body and handler are turned into separate functions white_closure_header
    are called from JavaScript

  - there is probably a bug or 2 in this code
*)
type exception_fn = {
  name: string;
  expression: expression;
  mem_pointer: int32;
  locals: (string * value_type) list;
  is_handler: bool;
  exn_name: string option
}

let exception_fns:((exception_fn list) ref) = ref []
let create_exception_function ?is_handler:(is_handler = false) ?exn_name (context:context) mem_pointer (name: string) (instr:expression) = (
    let fn_id = (-1l) in
    let (st:((string * value_type) list) ref) = ref [] in
    VarMap.iter (fun key (_, t) -> st := !st @ [(key, t)]) context.locals.l_map;
    let e_fn = {
      name = name;
      expression = instr;
      mem_pointer = mem_pointer;
      locals = !st;
      is_handler = is_handler;
      exn_name
    }
    in
    exception_fns := !exception_fns @ [e_fn];
    fn_id
)

let blockheader_details header =
    let word_size = Nativeint.shift_right header 10 in
    let tag = (Nativeint.logand header 255n) in
    (word_size, tag)

let rec to_operations context (expression_list:expression list) operation =
  let result = (match operation, expression_list with
  | Capply _, _ -> failwith "!!! This apply is not handled correctly !!!"
  | Cextcall (symbol, mt, _, _), _ -> (
      let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
      expression_list @
      (if not (func_symbol_exists symbol) then 
        (create_import_symbol symbol mt;
        [Call symbol])
      else
        [Call symbol])
    )
  | Cload (memory_chunk, _), _ -> (
      let align = 0 in
      let offset = 0l in
      let instr = Ast.Types.(match memory_chunk with
      | Byte_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, ZX)}]
      | Byte_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, SX)}]
      | Sixteen_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, ZX)}]
      | Sixteen_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, SX)}]
      | Thirtytwo_unsigned -> [Load {ty = I32Type; align; offset; sz = None}]
      | Thirtytwo_signed -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_int -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_val -> [Load {ty = I32Type; align; offset; sz = None}]
      | Single -> [Load {ty = I32Type; align; offset; sz = None}]

      (* for now we are targetting the 32bit version of wasm, in the future
         there might be a 64bit version *)
      | Double -> [Load {ty = F32Type; align; offset; sz = None}]
      | Double_u -> [Load {ty = F32Type; align; offset; sz = None}])
      in
      let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
      expression_list @ instr
    )
  | Calloc, Cblockheader (header, _) :: _ -> (
      let (word_size, _) = blockheader_details header in
      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let local_ = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      let position = ref 0 in
      

      let calls = List.fold_left (fun calls f ->         
        let result = calls @
        ([GetLocal local_;
        Const (I32 (I32.of_int_s !position));
        Binary (I32 I32Op.Add)]
        @
        (match f with 
        | Cconst_symbol symbol -> [DataSymbol symbol]
        | _ as e -> emit_expr context e)
        @
        [Store {ty = Types.I32Type; align = 0; offset = 0l; sz = None}])        
        in
        position := !position + Nativeint.to_int word_size;
        result
      ) [] expression_list
      in      
      
      let result = [Const (I32 (Nativeint.to_int32 word_size));
       Call "caml_alloc";
       SetLocal local_
      ]
      @
      calls
      @
      [GetLocal local_; (* return the value after the OCaml block header *)
       Const (I32 4l); (* FIX me: should not need to add 4 *)
       Binary (I32 I32Op.Add)
      ]
      in 
      result
    )
  | Cstore (memory_chunk, _), _ ->
    let align = 0 in
    let offset = 0l in
    let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
    let instr = Ast.Types.(match memory_chunk with
    | Byte_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Byte_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Sixteen_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Sixteen_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Thirtytwo_unsigned -> [Store {ty = I32Type; align; offset; sz = None}]
    | Thirtytwo_signed -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_int -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_val -> [Store {ty = I32Type; align; offset; sz = None}]
    | Single -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double_u -> [Store {ty = F32Type; align; offset; sz = None}])
    in
    current_return_type := [];
    expression_list @ instr
  | Cadda, [fst; snd] -> (* derived heap pointer *)
    let result = (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
    in
    result
  | Caddv, [fst; snd] -> (* pointer addition that produces a [Val] (well-formed Caml value) *)
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
  | Caddi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
  | Csubi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Sub)]
  | Cmuli, [fst; snd]
  | Cmulhi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Mul)]
  | Cdivi, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
   [Binary (I32 I32Op.DivS)]
  | Cmodi, [fst; snd] ->
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let cmod_local = bind_local context ("cmod_" ^ string_of_int counter) I32Type in
    let cmod_local2 = bind_local context ("cmod2_" ^ string_of_int counter) I32Type in
    (emit_expr context fst) @
     [SetLocal cmod_local;
      GetLocal cmod_local;
      GetLocal cmod_local] @
     (emit_expr context snd) @
     [TeeLocal cmod_local2;
      Binary (I32 I32Op.DivS);
      GetLocal cmod_local2;
      Binary (I32 I32Op.Mul);
      Binary (I32 I32Op.Sub)]
  | Cand, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.And)]
  | Cor, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Or)]
  | Cxor, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Xor)]
  | Clsl, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.Shl)]
  | Clsr, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.ShrU)]
  | Casr, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.ShrS)]
  | Ccmpi Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpi Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]
  | Ccmpi Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]
  | Ccmpi Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpi Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]
  | Ccmpi Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]
  | Caddv, _ -> failwith "caddv" (* pointer addition that produces a [Val] (well-formed Caml value) *)
  (* pointer addition that produces a [Addr] (derived heap pointer) *)
   | Ccmpa Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpa Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]
  | Ccmpa Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]
  | Ccmpa Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpa Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]
  | Ccmpa Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]
  | Cnegf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Neg)]
  | Cabsf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Abs)]
  | Caddf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Add)]
  | Csubf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Sub)]
  | Cmulf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Mul)]
  | Cdivf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Div)]
  | Cfloatofint, [fst] ->
    (emit_expr context fst) @
     [Convert (F32 F32Op.ReinterpretInt)]
  | Cintoffloat, [fst] ->
    (emit_expr context fst) @
     [Convert (I32 I32Op.ReinterpretFloat)]
  | Ccmpf CFeq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Eq)]
  | Ccmpf CFneq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ne)]
  | Ccmpf CFlt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Lt)]
  | Ccmpf CFnlt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFngt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnle, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnge, _ ->
    failwith "Not supported yet"
  | Ccmpf CFle, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Le)]
  | Ccmpf CFgt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Gt)]
  | Ccmpf CFge, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ge)]
  | Craise _, [arg] ->    
    (emit_expr context arg)
    @
    [Call "jsRaise_i32_i32"]
  | Ccheckbound, [fst; snd] -> (
    let fst = (emit_expr context fst) in
    let snd = (emit_expr context snd) in
    let if_ = fst @ snd @ [Compare (I32 I32Op.LtS)] in
    let else_ = snd @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)] in

    if_ @ [If ([], [
      DataSymbol "caml_exn_Invalid_argument";
      Call "jsRaise_i32_unit"
    ],else_ @ [If ([], [
        DataSymbol "caml_exn_Invalid_argument";
        Call "jsRaise_i32_unit"
      ], [])])]
    )
  | _ -> failwith ("Something is not handled here   ... :" ^ string_of_int (List.length expression_list)))
  in
  current_return_type := convert_result (oper_result_type operation);
  result
and emit_expr (context:context) (expression:expression) =
  match expression with
  | Cconst_int i ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s i))]
  | Cconst_natint i ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cconst_float s ->
    current_return_type := [F32Type];
    [Const (F32 (F32.of_float s))]
  | Cconst_symbol symbol ->
    (
    try
      let (_, t) = local context symbol in
      current_return_type := [t];
      [Call symbol]
    with
    | _ -> 
      current_return_type := [I32Type];
      [
        DataSymbol symbol;
        Const (I32 4l); (* FIX me: should not need to add 4 *)
        Binary (I32 I32Op.Add)
      ])    
  | Cblockheader (i, _) ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cvar ident ->
    (try (
      let (var, t) = local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) in
      current_return_type := [t];
      [GetLocal var]
    )
    with
    | _ ->
      failwith ("Cvar not found: " ^ ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp)
    )
  | Clet (ident, arg, fn_body) -> (
    let binding_name = ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp in
    let let_id = bind_local context binding_name I32Type in
    let result = emit_expr context arg in
    current_return_type := [];
    let body = emit_expr context fn_body in

    let result = if result = [] then (
      failwith "Clet - unexpected empty result";
    )
    else result
    in
    let result = result
    @
    [SetLocal let_id]
    @
    body
    in
    result
    )
  | Cassign (i, e) -> ( (* not tested yet, might be wrong... *)
      let (l, _) = local context (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) in
      let e = emit_expr context e in
      current_return_type := [];
      e @
      [SetLocal l]
    )
  | Ctuple el ->
    List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] el
  | Cop (Capply _, (Cop (Cload _ as op, el, _))::tl, _) -> (
    let fn_args = ref [] in
    let expression_list = List.fold_left (fun lst f ->
      let result = emit_expr context f in
      fn_args := !fn_args @ !current_return_type;
      if List.length result > 0 then (
        lst @ result
      )
      else
        lst
    ) [] tl in
    let load_action = to_operations context el op in
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let name_ = "wasm_unique_name_" ^ string_of_int counter in
    let type_:Ast.type_ = {name = name_; details = FuncType (!fn_args, [I32Type])} in    
    let w = !wasm_module in
    wasm_module := Ast.{w with types = w.types @ [type_]};
    expression_list @
    load_action @
    [CallIndirect name_]
    )
  | Cop (Capply mt, (Cconst_symbol hd)::tl, _) -> (    
    let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] tl in
    expression_list @
    (if func_symbol_exists hd then    
      [Call hd]
     else (
      create_import_symbol hd mt;
      [Call hd])
    ))
  | Cop (operation, expression_list, _) ->
    to_operations context expression_list operation
  | Csequence (e1, e2) ->
    let a = emit_expr context e1 in
    let b = emit_expr context e2 in
    a @ b
  | Cifthenelse (if_, then_, else_) ->
    Stack.push "ifthenelse" block_stack;
    let i = emit_expr context if_ in
    current_return_type := [];
    let t = emit_expr context then_ in
    let e = emit_expr context else_ in
    ignore(Stack.pop block_stack);
    i @ [If (!current_return_type, t, e)]
  | Cswitch  (sw, ia, ea, _) -> (
    let rec create_block ints remaining =
      match ints, remaining with
      | i :: re, expr :: rest -> (
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block re rest in
        let e = child_block @ emit_expr context expr in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | _, [] -> (
        current_return_type := [];
        Stack.push (string_of_int (Array.length ia + 1)) block_stack;
        Stack.push (string_of_int (Array.length ia + 2)) block_stack;
        let tb = BrTable ((List.map (fun f -> Int32.of_int (2 + f)) (Array.to_list ia)), 1l) in
        let e = emit_expr context sw in
        let result = [Block(!current_return_type, [Block (!current_return_type, [Const (I32 2l)] @ e @ [Binary (I32 I32Op.Sub)] @ [tb])]);] in
        ignore(Stack.pop block_stack);
        ignore(Stack.pop block_stack);
        result
      )
      | _ -> failwith "Should not happen..."
    in create_block (Array.to_list ia) (Array.to_list ea)
    )
  | Cloop e ->
    Stack.push "loop" block_stack;
    let expr = emit_expr context e in
    ignore(Stack.pop block_stack);
    let expr = expr @ [Br 0l] in
    [Loop ([], expr)]
  | Ccatch  (_, with_, body) -> (     
    let rec create_block = function
      | (i, il, expr) :: rest -> (
        List.iter (fun i -> (
          (* type is always i32type which is incorrect, but maybe not significant.. maybe... *)
          ignore(bind_local context (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) I32Type);
        )) il; 
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block rest in
        let e = child_block @ emit_expr context expr in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | [] ->
        current_return_type := [];
        let e = emit_expr context body in
        [Block (!current_return_type, e)]
    in
    let blocks = create_block with_ in
    let temp_local = ref (-1l) in
    let rec fix_blocks depth result = function
    | Block (rt, el) :: remaining -> (
        if (depth = -1 && List.length rt > 0) then (
          let counter = !unique_name_counter in
          unique_name_counter := !unique_name_counter + 1;
          temp_local := bind_local context ("return_value_" ^ string_of_int counter) (List.nth rt 0)
        );
        fix_blocks depth (result @ [Block ([], fix_blocks (depth + 1) [] el)]) remaining
      )
    | If (_, t, e) :: remaining -> (
        fix_blocks depth (result @ [If ([], fix_blocks (depth + 1) [] t, fix_blocks (depth + 1) [] e)]) remaining
      )
    | Loop ([], e) :: remaining -> (
      fix_blocks depth (result @ [Loop ([], fix_blocks (depth + 1) [] e)]) remaining
      )
    | _ as item :: remaining -> (
      let add = (match item with
      | BrTable _
      | Br _ -> []
      | _ ->
        if List.length remaining = 0 then (
            [SetLocal !temp_local; Br (Int32.of_int depth)]
          )
          else
            []
        )
      in
      fix_blocks depth (result @ [item] @ add) remaining
    )
    | [] -> result
    in
    let f = (fix_blocks (-1) [] blocks) in
    let x = if !temp_local <> (-1l) then
      [GetLocal !temp_local]
    else
      []
    in
    f @ x)
  | Cexit (i, el) ->
    (
      let el = List.fold_left (fun all e ->
        all @ (emit_expr context e)
      ) [] el in
      let position = ref 0 in
      let result = ref [] in
      Stack.iter (fun str ->
        position := !position + 1;
        if str = string_of_int i then (
          result := [Br (Int32.of_int (!position - 1))]
        )
      ) block_stack;
      el @
      !result
    )
  | Ctrywith  (body, exn, handler) ->
    (
      let memory_alloc_size = ref 0 in
      VarMap.iter (fun _ (_, t) ->
        match t with
        | I32Type
        | F32Type -> memory_alloc_size := !memory_alloc_size + 4
        | I64Type
        | F64Type -> memory_alloc_size := !memory_alloc_size + 8
      ) context.locals.l_map;

      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let alloc_memory_pointer = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      
      let store_instructions = ref
      [Const (I32 (I32.of_int_s !memory_alloc_size));
       Call "caml_alloc";
       SetLocal alloc_memory_pointer
      ]
      in
      let set_blocks = ref [] in
      let get_blocks = ref [] in
      let memory_block_position = ref 4 in (* first block is reserved for the return value *)
      VarMap.iter (fun _ (value, t) ->
        set_blocks := !set_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> (
                [GetLocal value;
                 Store {ty = I32Type; align = 0; offset = 0l; sz = None}]
              )
            | F32Type -> (
                [GetLocal value;
                 Store {ty = F32Type; align = 0; offset = 0l; sz = None}]
              )
            | _ -> failwith "not supported"
          );
        get_blocks := !get_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> [Load {ty = I32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | F32Type -> [Load {ty = F32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | _ -> failwith "not supported"
          );
        (* match t with
          | I32Type
          | F32Type -> ( *)
          memory_block_position := !memory_block_position + 4;
            (* ) *)
          (* | _ -> assert false *)
      ) context.locals.l_map;
      let body_fn_id = create_exception_function context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_body") body in
      let exn_name = (exn.Ident.name ^ "_" ^ string_of_int exn.Ident.stamp) in
      let handler_fn_id = create_exception_function ~is_handler:true ~exn_name context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_handler") handler in
      
      current_return_type := [I32Type];
      !store_instructions @
      !set_blocks @
      [
      GetLocal alloc_memory_pointer;
      Const (I32 body_fn_id);
      Const (I32 handler_fn_id);
      Call "caml_alloc"] @
      !get_blocks @
      [ GetLocal alloc_memory_pointer;
        Load {ty = I32Type; align = 0; offset = 0l; sz = None}; (* TODO: also support float return value... *)
      ]
    )




let begin_assembly () = (
  let globals = [{
    name = "global_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s !global_offset))]
  };
  {
    name = "global_memory_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s 0))]
  }
  ]
  in
  let data = [{
    index =  0l;
    offset = [Const (I32 0l)];
    init = {
      name = "caml_globals_inited";
      detail = [Int8 0]
    };
  }; {
    index =  0l;
    offset = [Const (I32 1l)];
    init = {
      name = "caml_backtrace_pos";
      detail = [Int32 0l]
    };
  };
  ]
  in
  
  let w = !wasm_module in
  wasm_module := {w with symbols = w.symbols @ [{
    name = "caml_globals_inited";
    details = Data ({
      index = 0l;
      relocation_offset = 0l;
      size =  1l;
      offset = 0l;
    })
  };
  {
    name = "caml_backtrace_pos";
    details = Data ({      
      index = 1l;
      relocation_offset = 0l;
      size =  4l;
      offset = 1l;
    })
  };
  ]};

  global_offset := !global_offset + 5; (* TODO: make this a bit smarter (eg. count the previous sizes) *)

  let jsTryWithType:Ast.type_ = {name = "jsTryWithType"; details = Types.FuncType ([Types.I32Type;Types.I32Type;Types.I32Type], [])} in
  let type_:Ast.type_ = {name = "type_"; details = Types.FuncType ([Types.I32Type], [Types.I32Type])} in
  let empty_type:Ast.type_ = {name = "empty_type"; details = Types.FuncType ([], [])} in
  let raise_i32_unit:Ast.type_ = {name = "raise_i32_ftype"; details = Types.FuncType ([Types.I32Type], [])} in
  let types = [ jsTryWithType; type_; empty_type; raise_i32_unit] in
  
  let imports = [
    {
      module_name = name "js";
      item_name = name "tryWith";
      idesc = FuncImport "jsTryWithType"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_i32";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_unit";
      idesc = FuncImport "raise_i32_ftype"
    };
    {
      module_name = name "js";
      item_name = name "caml_fresh_oo_id";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "libasmrun";
      item_name = name "caml_alloc";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "linking";
      item_name = name "camlCamlinternalFormatBasics__entry";
      idesc = FuncImport "empty_type"
    };
    {
      module_name = name "linking";
      item_name = name "camlPervasives__entry";
      idesc = FuncImport "empty_type"
    };
  ]
  in

  
  create_import_symbol "jsTryWith" [||];
  create_import_symbol "jsRaise_i32_i32" [||];
  create_import_symbol "jsRaise_i32_unit" [||];
  create_import_symbol "caml_fresh_oo_id" [||];
  create_import_symbol "caml_alloc" [||];
  create_import_symbol "camlCamlinternalFormatBasics__entry" [||];
  create_import_symbol "camlPervasives__entry" [||];

  let exports = [
  {
    name = name "table";
    edesc = TableExport 0l;
  };
  {
    name = name "memory";
    edesc = MemoryExport 0l;
  }
  ]
  in
  let w = !wasm_module in
  wasm_module := Ast.{w with
    globals = globals;
    types = types;
    data = data;
    imports = imports;
    exports = exports;
  };
)

(* let rec add_exception_functions ppf = (
  let _exception_fns = !exception_fns in
  exception_fns := [];
  List.iter (fun {name; expression; mem_pointer; locals; is_handler; exn_name} -> (
    let exn_name = match exn_name with
    | Some s -> s
    | _ -> ""
    in
    compile_wasm_phrase  ~locals ~is_handler ~exn_name ppf (Cfunction ({
      fun_name = name;
      fun_args = [];
      fun_body = expression;
      fun_codegen_options = [];
      fun_dbg = []
      }))
    )) _exception_fns;

) *)

let fundecl ({fun_name; fun_args; fun_body; _}) = (    
    let context = enter_func () in
    let args = ref [] in
    List.iter (fun (ident, mt) ->
      let value_type = match mt with
      | [|Val|]
      | [|Addr|]
      | [|Int|] -> I32Type
      | [|Float|] -> F32Type
      | _ -> failwith "Unexpected combination of machtypes"
      in
      ignore(bind_local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) value_type);
      args := [Types.I32Type] @ !args;
    ) fun_args;

    print_string (fun_name ^ " - ");

    List.iter Ident.(fun (ident, mt) ->
      print_string (" @" ^ ident.name ^ ":");
      match mt with
      | [|Val|] -> print_string "val"
      | [|Addr|] -> print_string "addr"
      | [|Int|] -> print_string "int"
      | [|Float|] -> print_string "float"
      | _ -> failwith "Unexpected combination of machtypes"
    ) fun_args;
    
    print_endline "";
    
    create_func_symbol fun_name [||];
    
    (* remove unit return value *)
    let rec remove_last_unit fun_body =
      match fun_body with            
      | Csequence (expr, Cconst_int 1) -> expr
      | Csequence (expr1, Csequence (a, b)) -> Csequence (expr1, remove_last_unit (Csequence (a, b)))
      | _ as e -> e
    in
    let fun_body = remove_last_unit fun_body in    
    let fun_body = emit_expr context fun_body in        
    let body = fun_body in
    let type_:Ast.type_ = {name = fun_name; details = Types.FuncType (!args, !current_return_type)} in
    let locals = ref [] in
    VarMap.iter (fun _ (_, t) -> locals := !locals @ [t]) context.locals.l_map;
    let result = {
      name = fun_name;
      ftype = fun_name;
      locals = !locals;
      body;
    } in
    let export = {
      name = name fun_name;
      edesc = FuncExport fun_name;
    } in

    let w = !wasm_module in
    wasm_module := Ast.{w with funcs = w.funcs @ [result];
                               types = w.types @ [type_];
                               exports = w.exports @ [export];
                               };
)
and data dl = (
    if List.length dl > 0 then (
        let init = ref [] in
        let start_offset = !global_offset in
        (* let data_id = ref 0l in *)
        let offset = ref 0 in        
        let symbol_name = ref "" in
        let size = ref 0n in
        let is_closure =
            match List.hd dl with
            | Cint i when (((Nativeint.to_int i) land 255) == 247) -> 
              let (s, _) = blockheader_details i in
              size := s;
              true
            | _ -> false
        in
        List.iter (function
        | Cglobal_symbol _ -> ()
        | Csymbol_address symbol -> (            
            let add =
              if is_closure then 
                ((if not (func_symbol_exists symbol) then (
                  (* let no_of_args = Nativeint.to_int (Nativeint.shift_right !size 1) in *)
                  create_import_symbol symbol [||]));
                [FunctionLoc symbol])
              else             
                [Symbol symbol]            
            in
            init := !init @ add;
            offset := !offset + 4;
            ()
            )
        | Cdefine_symbol symbol -> symbol_name := symbol
        | Cint8 i -> (
            init := !init @ [Int8 i];
            offset := !offset + 1;
            ()
            )
        | Cint16 i -> (
            init := !init @ [Int16 i];
            offset := !offset + 2;
            ()
            )
        | Cint32 ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Cint ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Csingle d
        | Cdouble d -> (
            init := !init @ [Float32 (F32.of_float d)];
            offset := !offset + 4;
            ()
            )
        | Cstring s -> (
            init := !init @ [Ast.String s];
            offset := !offset + (String.length s);
            ()
            )
        | Cskip _ -> ()
        | Calign _ -> () (* seems not to be produced anyway in the OCaml codebase *)
        ) dl;

        (* print_endline ("Offset for " ^ !symbol_name ^ " = " ^ string_of_int start_offset); *)
        let w = !wasm_module in
        wasm_module := {w with symbols = w.symbols @ [{
          name = !symbol_name;
          details = Data ({
              index = 0l;
              relocation_offset = 0l;
              size =  Int32.of_int !offset;
              offset = Int32.of_int start_offset
          })
        }]};
        
        let w = !wasm_module in

        global_offset := !global_offset + !offset;

        (* to make sure that this is always seen as data and not an integer *)
        (if !global_offset land 1 <> 0 then global_offset := !global_offset + 1);
        wasm_module := Ast.{w with data = w.data @ [{
        index =  0l;
        offset = [Const (I32 (I32.of_int_s start_offset))];
        init = {
            name = !symbol_name;
            detail = !init
        }
        }];
    }
    )
)