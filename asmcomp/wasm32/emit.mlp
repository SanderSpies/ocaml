(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                             Sander Spies                               *)
(*                                                                        *)
(*   Copyright 2017 - 2018                                                *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* From C-- to WebAssembly object file AST *)

open Cmm
open Ast
open Values
open Wasm_types

(*
  WebAssembly (wasm) is a secure stackmachine. It guarantees security by using 
  type safety for all variables, limiting memory access, and having no access 
  to the stack. 
  
  It's possible to hack around not having stack access, but it's probably wiser 
  to wait for the right additions in wasm to appear. Luckily this already being 
  worked on:
  - https://github.com/WebAssembly/exception-handling/blob/master/proposals/Level-1.md
  - https://github.com/WebAssembly/gc/pull/34 
  - https://github.com/WebAssembly/tail-call/blob/master/proposals/tail-call/Overview.md 

  The code is compiled to the wasm object file format, which is defined here: 
  https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md. This
  is required to be able to use LLVM's LLD to link the generated wasm binary 
  with other code that's compiled to wasm (from clang for example).
*)

module VarMap = Map.Make(String)

type local_space = {mutable l_map : (int32 * value_type list * string) VarMap.t; mutable l_count : int32}


(* 
  - should this have a type declaration? probably only if there is a sibling!
 *)
type block_stack_item =
| BLoop
| BIfthenelse of bool
| BCswitch_container
| BCswitch_main
| BCswitch_case
| BWith of (int * bool * value_type list) 
| BCcatch 
| BCheckbound1
| BCheckbound2

type block_stack = block_stack_item Stack.t
(* type local_stack = value_type Stack.t *)

(* the resulting wasm module *)
let wasm_module = ref {
  types = [];
  globals = [];
  tables = Types.[{
    ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
  }];
  memories = Types.[{
    (* TODO: this needs to be improved when doing GC *)
    mtype = MemoryType {min = 100l; max = Some 100l}
  }];
  funcs = [];
  start = None;
  elems = [];
  data = [];
  imports = [];
  exports = [];
  symbols = [];
}

let empty_locals () = {l_map = VarMap.empty; l_count = 0l};

type context =
  { locals : local_space }

let empty_context () =
  { locals = empty_locals() }

let block_stack : block_stack = Stack.create ()

(* let local_stack : local_stack = Stack.create () *)

let lookup_local space x =
  VarMap.find x space.l_map

let local (c : context) x = 
  let result = lookup_local c.locals x in 
  result

let context = ref (empty_context ())

let bind_local (space:local_space) x (value_types:value_type list) =
  if VarMap.mem x space.l_map then
    failwith ("Duplicate:" ^ x);
  let i = space.l_count in
  space.l_map <- VarMap.add x (space.l_count, value_types, x) space.l_map;
  space.l_count <- Int32.add space.l_count 1l;
  if space.l_count = 0l then
    failwith "Too many bindings";
  i

let func_symbol_exists symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import _ when name = symbol -> true
    | Function _ when name = symbol -> true        
    | _ -> false
  ) w.symbols

let is_import symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import _ when name = symbol -> true
    | _ -> false
  ) w.symbols

let create_func_symbol symbol mt = (* TODO: move to encode *)
  if symbol = "" then failwith "2 Name can't be empty";
  if not (func_symbol_exists symbol) then (    
    let w = !wasm_module in
    wasm_module := {w with 
      symbols = w.symbols @ [{
        name = symbol;
        details = Function (0, 0)
      }]
    }
  )
  else if is_import symbol then (
    let w = !wasm_module in
    wasm_module := {w with symbols = List.map (fun s -> (
      if (s.name = symbol) then
        {
        name = symbol;
        details = Function mt
      }
      
      else s
          )) w.symbols
    }
  )

let create_import_symbol name args result =
  if name = "" then failwith "Name can't be empty";  
  if not (func_symbol_exists name) then (    
    let w = !wasm_module in
    wasm_module := {w with 
      symbols = w.symbols @ [{
        name = name;
        details = Import (args, result)
      }]
    }
  )

let create_symbol_table () = ( (* TODO: move to encode *)
  let w = !wasm_module in
  let global_symbols = (List.mapi (fun i (g:Ast.global) -> 
    {
    name = g.name;
    details = Global ({
      index = Int32.of_int i;      
    })
  }) w.globals)
  in
  wasm_module := {w with
    symbols =
      w.symbols @ global_symbols 
  }
)

let bind_local (c : context) name value_types = bind_local c.locals name value_types

let current_return_type = ref []



let unique_name_counter = ref 0

let name s =
  try Utf8.decode s with Utf8.Utf8 ->
    failwith "invalid UTF-8 encoding"

let global_offset = ref 0

let end_assembly () = (  
  create_symbol_table (); (* Move to Encode *)
  Encode.encode !wasm_module;  
  wasm_module := {
    types = [];
    globals = [];
    tables = Types.[{
      ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
    }];
    memories = Types.[{
      (* TODO: this needs to be improved when doing GC *)
      mtype = MemoryType {min = 100l; max = Some 100l}
    }];
    funcs = [];
    start = None;
    elems = [];
    data = [];
    imports = [];
    exports = [];
    symbols = []; (* Move to Encode *)
  };
  context := empty_context ();
  current_return_type := [];  
)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(_s, ty, _alloc, _) -> ty
  | Cload (c, _) ->
      begin match c with
      | Word_val -> typ_val
      | Single | Double | Double_u -> typ_float
      | _ -> typ_int
      end
  | Calloc -> typ_val
  | Cstore (_c, _) -> typ_void
  | Caddi | Csubi | Cmuli | Cmulhi | Cdivi | Cmodi |
    Cand | Cor | Cxor | Clsl | Clsr | Casr |
    Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Caddv -> typ_val
  | Cadda -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise _ -> typ_int
| Ccheckbound -> typ_void

let convert_result = function 
   | [||] -> []   
   | [|Float|] -> [F32Type]   
   | [|Val|]
   | [|Addr|]
   | [|Int|] -> 
      [I32Type]
   | _ -> assert false

(*
  FIXME: Exceptions are completely broken at the moment!

  exceptions are tricky for now as wasm doesn't support it.

  Right now it works as follows:
  - within JS we raise and catch exceptions
  - the tryWith body and handler are turned into separate functions white_closure_header
    are called from JavaScript

  - there is probably a bug or 2 in this code
*)
(* type exception_fn = {
  name: string;
  expression: expression;
  mem_pointer: int32;
  locals: (string * value_type) list;
  is_handler: bool;
  exn_name: string option
} *)
(* 
let exception_fns:((exception_fn list) ref) = ref []
let create_exception_function ?is_handler:(is_handler = false) ?exn_name (context:context) mem_pointer (name: string) (instr:expression) = (
    let fn_id = (-1l) in
    let (st:((string * value_type) list) ref) = ref [] in
    VarMap.iter (fun key (_, t) -> st := !st @ [(key, t)]) context.locals.l_map;
    let e_fn = {
      name = name;
      expression = instr;
      mem_pointer = mem_pointer;
      locals = !st;
      is_handler = is_handler;
      exn_name
    }
    in
    exception_fns := !exception_fns @ [e_fn];
    fn_id
) *)

(* let print_local_stack prefix =
  print_string (prefix ^ " (");
  Stack.iter (fun f -> 
    match f with 
    | I32Type -> print_string "i32 "
    | I64Type -> print_string "i64 "
    | F32Type -> print_string "f32 "
    | F64Type -> print_string "f64 "
  ) local_stack;
  print_endline ")"

let push_local_stack a  =
  List.iter (fun kind -> 
    ignore(Stack.push kind local_stack)
  ) a

let pop_local_stack a =
  for _i=0 to a - 1 do 
    ignore(Stack.pop local_stack)
  done *)

let blockheader_details header =
    let word_size = Nativeint.shift_right header 10 in
    let tag = (Nativeint.logand header 255n) in
    (word_size, tag)

let branch_calls: (int32 * value_type list) list ref = ref []

let branch_call pos crt =
  branch_calls := !branch_calls @ [(pos, crt)];
  current_return_type := [];
  Br pos

let is_target () = 
  let f = List.find_opt (fun (f, _) -> f = 0l) !branch_calls in
  match f with 
  | Some (_, t) -> t
  | None -> []
  
let decrease_branch_calls () =
   branch_calls := List.fold_left (fun all (br, crt) -> 
    let new_br = Int32.sub br 1l in
    if new_br <> -1l then (
      all @ [(new_br, crt)])
    else 
      all
  ) [] !branch_calls

let enter_func () = (
  current_return_type := [];
  branch_calls := [];
  {locals = empty_locals()}
)


let reset_top_ccatch = ref true
let find_top_ccatch () = (
  let top_catch = ref None in
  let depth = ref 0 in
  Stack.iter (fun n -> 
    (match n with 
    | BWith (_, true, _) when !top_catch = None -> 
      top_catch := Some (!depth + 1)
    | _ -> depth := !depth + 1
    );    
  ) block_stack;  
  !top_catch
)

let structured_instruction name e s =  
  Stack.push name block_stack;    
  let expr = e () in
  let is_target = is_target () in
  let result = s is_target !current_return_type expr in
  decrease_branch_calls();
  ignore(Stack.pop block_stack);
  result

(* let is_in_ite () = 
  let is_inside = ref false in
  let iter = ref 0 in
  Stack.iter (fun n -> 
    (match n with 
    | BIfthenelse when !iter = 1 -> is_inside := true;
    | _ -> ());
    iter := !iter + 1;
  ) block_stack;
  !is_inside *)

(*
  At several places OCaml has implicit branch calls that need to be made 
  explicit for wasm.
*)
let add_additional_br e depth crt = 
  let last_item = List.hd (List.rev e) in
  e @ (match last_item with
  | Block _
  | If _ 
  | Loop _
  | BrTable _
  | Br _  -> []
  | _ -> 
    [branch_call (I32.of_int_s (depth - 1)) crt]    
  )

let block_instruction name e = 
  structured_instruction 
    name
    e
    (fun _i _t e ->
      (* TODO..... *)
      [Block (!current_return_type, e)]
    )

let if_instruction name e =
  structured_instruction 
    name
    e
    (fun _i _t e -> 
      let (i, th, e) = e in
      i @ [If (!current_return_type, th, e)]
    )

let loop_instruction e = 
  structured_instruction
    BLoop
    e
    (fun _ _ e ->
      [Loop ([], e)]
    )

let has_sibling = ref false

let rec to_operations  (context) (expression_list:expression list) (operation:Cmm.operation) : Ast.instr list =     
  let result = (match operation, expression_list with
  | Capply _, _ -> failwith "!!! This apply is not handled correctly !!!"
  | Cextcall (symbol, mt, _, _), _ -> (            
      let (args, expression_list) = (List.fold_left (fun (lst:stack_type * Ast.instr list) f -> 
        let (args, expression_list) = lst in
        let expr = emit_expr context f in
        (* pop_local_stack 1; *)
        (args @ !current_return_type, expression_list @ expr)) ([], []) expression_list)
      in
      let drop = if Array.length mt = 0 then 
        (current_return_type := [];
        [Drop] )
      else 
        [] 
      in
      expression_list
      @
      (if not (func_symbol_exists symbol) then 
        (
          (match mt with 
          | [|Float|] -> create_import_symbol symbol args [F32Type]
          | _ -> create_import_symbol symbol args [I32Type]);
          
        [Call symbol] @ drop)
      else (
        [Call symbol] @ drop)
      )      
      )
  | Cload (memory_chunk, _), [el1] -> (
      let align = 0 in
      let offset = 0l in
      (* ignore(Stack.pop local_stack); *)
      let instr = 
         (Ast.Types.(match memory_chunk with
      | Byte_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, ZX)}]
      | Byte_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, SX)}]
      | Sixteen_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, ZX)}]
      | Sixteen_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, SX)}]
      | Thirtytwo_unsigned -> [Load {ty = I32Type; align; offset; sz = None}]
      | Thirtytwo_signed -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_int -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_val -> [Load {ty = I32Type; align; offset; sz = None}]
      | Single -> [Load {ty = I32Type; align; offset; sz = None}]

      (* for now we are targetting the 32bit version of wasm, in the future
         there might be a 64bit version *)
      | Double -> [Load {ty = F32Type; align; offset; sz = None}]
      | Double_u -> [Load {ty = F32Type; align; offset; sz = None}]))
      in
      print_endline "load before";
      let expression_list = (emit_expr context el1) in
      print_endline "load after";
      (* print_endline "load2"; *)
      (* ignore(Stack.push I32Type local_stack);   *)
      (* print_local_stack "Cload"; *)
      expression_list @ instr
    )
  | Calloc, Cblockheader (header, _) :: _ -> (
      let (word_size, tag) = blockheader_details header in
      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let local_ = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) [I32Type] in
      let position = ref 0 in
      let calls = List.fold_left (fun calls f ->
        print_endline "z1";
        let result = calls @
        ([GetLocal local_;
        Const (I32 (I32.of_int_s !position));
        Binary (I32 I32Op.Add)]
        @
        (match f with 
        | Cconst_symbol symbol ->           
          let is_closure = ((Nativeint.to_int tag) land 255) == 247 in
          (if is_closure then (current_return_type := [I32Type]; [FuncSymbol symbol]) else [DataSymbol symbol]);
          
        | _ as e -> emit_expr context e))
        in
        let t = if !current_return_type = [] then 
            I32Type
          else 
            List.hd !current_return_type
        in
        
        let result = result @ [Store {ty = t; align = 0; offset = 0l; sz = None}]     
        in
        current_return_type := [];
        (* ignore(Stack.pop local_stack);         *)
        position := !position + Nativeint.to_int word_size;
        result
      ) [] expression_list
      in           
      let result = [Const (I32 (Nativeint.to_int32 word_size));
       Call "caml_alloc";
       SetLocal local_
      ]
      @
      calls
      @
      [GetLocal local_] (* return the value after the OCaml block header *)      
      in 
      print_endline "z2";
      current_return_type := [I32Type]; 
      result
    )
  | Cstore (memory_chunk, _), [el1; el2] ->
    
    let align = 0 in
    let offset = 0l in
    let expression_list = (emit_expr context el1) @ (emit_expr context el2) in
    let rt = List.hd !current_return_type in   
    let instr = Ast.Types.(match memory_chunk with
    | Byte_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Byte_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Sixteen_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Sixteen_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Thirtytwo_unsigned -> [Store {ty = rt; align; offset; sz = None}]
    | Thirtytwo_signed -> [Store {ty = rt; align; offset; sz = None}]
    | Word_int -> [Store {ty = rt; align; offset; sz = None}]
    | Word_val -> [Store {ty = rt; align; offset; sz = None}]
    | Single -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double_u -> [Store {ty = F32Type; align; offset; sz = None}])
    in
    current_return_type := [];
    expression_list @ instr
  | Caddv, [fst; snd] (* pointer addition that produces a [Val] (well-formed Caml value) *)    
  | Caddi, [fst; snd]    
  | Cadda, [fst; snd] -> (* derived heap pointer *)        
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Add)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cadd*"; *)
    result        
  | Csubi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Sub)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Csubi"; *)
    result        
  | Cmuli, [fst; snd]
  | Cmulhi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Mul)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cmul*"; *)
    result                
  | Cdivi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.DivS)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cdivi"; *)
    result                
  | Cmodi, [fst; snd] ->
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let cmod_local = bind_local context ("cmod_" ^ string_of_int counter) [I32Type] in
    let cmod_local2 = bind_local context ("cmod2_" ^ string_of_int counter) [I32Type] in
    (emit_expr context fst) @
     [SetLocal cmod_local;
      GetLocal cmod_local;
      GetLocal cmod_local] @
     (emit_expr context snd) @
     [TeeLocal cmod_local2;
      Binary (I32 I32Op.DivS);
      GetLocal cmod_local2;
      Binary (I32 I32Op.Mul);
      Binary (I32 I32Op.Sub)]
  | Cand, [fst; snd] ->    
   let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.And)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cand"; *)
    result
  | Cor, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Or)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result        
  | Cxor, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Xor)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result               
  | Clsl, [fst; snd] ->
  let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Shl)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result              
  | Clsr, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.ShrU)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result            
  | Casr, [fst; snd] ->    
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.ShrS)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result            
  | Ccmpi Ceq, [fst; snd] ->
    (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (I32 I32Op.Eq)]      
  | Ccmpi Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]      
  | Ccmpi Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]      
  | Ccmpi Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpi Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]      
  | Ccmpi Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]      
  | Caddv, _ -> failwith "caddv" (* pointer addition that produces a [Val] (well-formed Caml value) *)
  (* pointer addition that produces a [Addr] (derived heap pointer) *)
   | Ccmpa Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpa Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]      
  | Ccmpa Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]      
  | Ccmpa Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
      [Compare (I32 I32Op.LeS)]      
  | Ccmpa Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]      
  | Ccmpa Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
      [Compare (I32 I32Op.GeS)]      
  | Cnegf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Neg)]
  | Cabsf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Abs)]
  | Caddf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Add)]
  | Csubf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Sub)]
  | Cmulf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Mul)]
  | Cdivf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Div)]
  | Cfloatofint, [fst] ->
    (emit_expr context fst) @
     [Convert (F32 F32Op.ReinterpretInt)]
  | Cintoffloat, [fst] ->
    (emit_expr context fst) @
     [Convert (I32 I32Op.ReinterpretFloat)]
  | Ccmpf CFeq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Eq)]
  | Ccmpf CFneq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ne)]
  | Ccmpf CFlt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Lt)]
  | Ccmpf CFnlt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFngt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnle, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnge, _ ->
    failwith "Not supported yet"
  | Ccmpf CFle, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Le)]
  | Ccmpf CFgt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Gt)]
  | Ccmpf CFge, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ge)]
  | Craise _, [arg] ->     
    let x = (emit_expr context arg) in

    current_return_type := [I32Type];
    
    x @
    [Call "jsRaise_i32_i32"]
  | Ccheckbound, [fst; snd] -> 
    let fst = (emit_expr context fst) in
    let snd = (emit_expr context snd) in    
    
    if_instruction 
      BCheckbound1
      (fun () ->         
        current_return_type := [];
        let i = fst @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)] in
        current_return_type := [];
        let t = [
          DataSymbol "caml_exn_Invalid_argument";
          Call "jsRaise_i32_unit"
        ] in
        current_return_type := [];
        let e = if_instruction
          BCheckbound2
          (fun () -> 
            (snd @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)], [
              DataSymbol "caml_exn_Invalid_argument";
              Call "jsRaise_i32_unit"
            ], [])
          )
          
          in
        (i, t, e)
      )            
  | _ -> failwith ("Something is not handled here   ... :" ^ string_of_int (List.length expression_list)))
  in  
  current_return_type := convert_result (oper_result_type operation);    
  result
and emit_expr (context:context) (expression:expression) =
  (match expression with 
  | Ccatch _ -> ();
  | _ -> 
    reset_top_ccatch := true);

  match expression with
  | Cconst_int i -> 
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cconst_int"; *)
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s i))]
  | Cconst_natint i -> 
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cconst_natint"; *)
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cconst_float s ->
    (* Stack.push F32Type local_stack; *)
    (* print_local_stack "Cconst_float"; *)
    current_return_type := [F32Type];
    [Const (F32 (F32.of_float s))]
  | Cconst_symbol symbol ->
    (      
    try
      let (_, t, _) = local context symbol in
      current_return_type := t;
      (* Stack.push t local_stack; *)
      (* print_local_stack "Cconst_symbol"; *)
      [Call symbol]
    with
    | _ -> 
      (current_return_type := [I32Type];      
      (* Stack.push I32Type local_stack; *)
      (* print_local_stack "Cconst_symbol"; *)
      [DataSymbol symbol]))
  | Cblockheader (i, _) ->
    current_return_type := [I32Type];
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cblockheader"; *)
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cvar ident ->
    (try (
      let (var, t, _) = local context (ident.Ident.name ^ "/" ^ string_of_int ident.Ident.stamp) in      
      current_return_type := t;
      (* Stack.push t local_stack; *)
      (* print_local_stack "Cvar"; *)
      print_endline "bum1";
      [GetLocal var]      
    )
    with
    | _ ->
      failwith ("Cvar not found: " ^ ident.Ident.name ^ "/" ^ string_of_int ident.Ident.stamp)
    )
  | Clet (ident, arg, fn_body) -> (
    
    let binding_name = ident.Ident.name ^ "/" ^ string_of_int ident.Ident.stamp in    
     
    print_endline "A1";
    let result = emit_expr context arg in    
    print_endline "A2";
    if (!current_return_type <> []) then (
      let let_id = bind_local context binding_name !current_return_type in 
      (* let crt = !current_return_type in *)
      current_return_type := [];
      (* has_sibling := true; *)
      print_endline "BODY BEFORE";
      let body = emit_expr context fn_body in
      (* has_sibling := false; *)
      print_endline "BODY END";
      let result = if result = [] then (
        failwith "Clet - unexpected empty result";
      )
      else result
      in
      let result = result
      @
        [SetLocal let_id]
      @
      body
      in      
      (* current_return_type := crt; *)
      result
    )
    else 
      result)
  | Cassign (i, e) -> (
      let name = (i.Ident.name ^ "/" ^ string_of_int i.Ident.stamp) in
      let (l, _, _) = local context name in
      let e = emit_expr context e in
      current_return_type := [];
      e @ [SetLocal l]
    )
  | Ctuple ([Cop (Cload _, _, _) as _el; Cop (Cload _, _, _) as el2]) ->
    print_endline "For now we are always treating 64bit as 32bit - so ignoring the first 4 bytes";
    (* print_endline "ctuple"; *)
    (* TODO ensure we are properly loading 64 bit here... *)
    let result = emit_expr context el2 in    
    (* print_local_stack "Ctuple (64bit cload)"; *)
    result
    (* let result = (emit_expr context el) in 
    current_return_type := [I32Type];
    result @ [
     Const (I32 4l);
     Binary (I32 I32Op.Shl)] @
    (emit_expr context el2) @
    [
     Binary (I32 I32Op.Add)]     *)
  | Ctuple el ->
    let result = List.fold_left (fun lst f -> 
      lst @ (emit_expr context f)) [] el in
    (* print_local_stack "Ctuple"; *)
    result
    
  | Cop (Capply mt, (Cop (Cload _ as op, el, _))::tl, _) -> (    
    print_endline "apply1";
    let fn_args = ref [] in
    let expression_list = List.fold_left (fun lst f ->
      let result = emit_expr context f in
      (* ignore(Stack.pop local_stack); *)
      fn_args := !fn_args @ !current_return_type;
      if List.length result > 0 then (
        lst @ result
      )
      else
        lst
    ) [] tl in
    let load_action = to_operations context el op in
    
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let name_ = "wasm_unique_name_" ^ string_of_int counter in
    let type_:Ast.type_ = {name = name_; details = FuncType (!fn_args, [I32Type])} in    
    let w = !wasm_module in
    let drop = (if Array.length mt = 0 then 
      (current_return_type := [];
      [Drop]) else []) in    
    wasm_module := Ast.{w with types = w.types @ [type_]};
    (* print_local_stack "Cop (Capply _, (Cop (Cload _ as op, el, _))::tl, _)"; *)
    expression_list @
    load_action @
    [CallIndirect name_] @ drop
    )
  | Cop (Capply mt, (Cconst_symbol hd)::tl, _) -> (    
    print_endline "Capply 2";
    has_sibling := true;
    let (args, expression_list) = List.fold_left (fun lst f -> 
      let (args, expression_list) = lst in      
      let expr = emit_expr context f in
      (* ignore(Stack.pop local_stack); *)
      (args @ !current_return_type, expression_list @ expr)) ([], []) tl 
      in
    (* (match mt with 
        | [|Val|]
        | [|Addr|]
        | [|Int|] -> Stack.push I32Type local_stack
        | [|Float|] -> Stack.push F32Type local_stack
        | [||] -> ()
        | _ -> assert false
      );
    print_local_stack "Cop (Capply _mt, (Cconst_symbol hd)::tl, _)"; *)
    let drop = (if Array.length mt = 0 then 
      (current_return_type := [];
      [Drop]) else 
      (        
        current_return_type := (match mt with 
        | [|Val|] | [|Int|] | [|Addr|] -> [I32Type]
        | [|Float|] -> [F32Type]
        | _ -> assert false
      );
      [])) in    
    (if not (func_symbol_exists hd) then (
      create_import_symbol hd args [I32Type])
    );
    print_endline "Dapply2 end";
    has_sibling := false;
    expression_list @ [Call hd] @ drop
  )
  | Cop (operation, expression_list, _) ->  
    to_operations context expression_list operation
  | Csequence (Csequence(e1, Ctuple ([])), Cconst_int 1) -> (
    print_endline "csequence D";
    let a = emit_expr context e1 in    
    a @ [Drop; Const (I32 1l)]
  )       
  | Csequence (e1, e2) ->
    has_sibling := true;    
    let a = emit_expr context e1 in
    has_sibling := false;
    let b = emit_expr context e2 in
    a @ b
  | Cifthenelse (if_2, then_, else_) ->    
    let sibling = !has_sibling in
    has_sibling := false;
    current_return_type := [];
    let i = emit_expr context if_2 in
    if_instruction 
      (BIfthenelse sibling)
      (fun () ->                 
        current_return_type := [];
        let t = emit_expr context then_ in
        let ty1 = !current_return_type in
        current_return_type := [];
        let e = emit_expr context else_ in
        let ty2 = !current_return_type in 
        Stack.iter(fun f -> 
          print_endline (match f with 
          | BLoop -> "loop"
          | BIfthenelse true -> "ifthenelse true"
          | BIfthenelse false -> "ifthenelse false"
          | BCswitch_container -> "switch container"
          | BCswitch_main -> "switch main"
          | BCswitch_case -> "switch case"
          | BWith _ -> "bwith"
          | BCcatch -> "ccatch"
          | BCheckbound1 -> "cb1"
          | BCheckbound2 -> "cb2")
        
        ) block_stack;
        let top_ccatch = 
          (if (sibling) then 
            Some 2
          else   
            find_top_ccatch ())
        in
        let (t,e) = match top_ccatch with 
        | Some s -> 
          let t = 
            if List.length t > 0 then (
              current_return_type := [];
              print_endline ("1. Add br to: " ^ string_of_int (s - 2) ^ ".");
              let result = add_additional_br t (s - 1) ty1 in
               (if sibling then 
                current_return_type := ty1);
              result)
            else
              t
          in              
          let e = 
            if List.length e > 0 then (
              current_return_type := [];
              print_endline ("2. Add br to: " ^ string_of_int (s - 2) ^ ".");
              let result = add_additional_br e (s - 1) ty2 in
              (if sibling then 
                current_return_type := ty2);
              result
            )
            else 
              e
          in   
          (if ty1 <> ty2 then 
            (
              print_endline "humbug.";
              let t = (match List.rev t with 
              | Block ([I32Type], be) :: rest -> 
                List.rev rest @ [Block ([], be)]
              | _ -> t)
              in
              let e = (match List.rev e with 
              | Block ([I32Type], be) :: rest -> 
                List.rev rest @ [Block ([], be)]
              | _ -> e)
              in 
              current_return_type := [];
              (t, e)
          )
          else 
            (t, e)
          )
        | None -> (t, e)
        in
        print_endline "IF STATEMENT END";
        (i, t, e)
      )            
  | Cswitch  (sw, ia, ea, _) -> ( 
    let ea = Array.to_list ea in
    let ia = Array.to_list ia in
    let depth = ref 0 in
    let rec create_block ints remaining =
      match ints, remaining with
      (* | _i :: re, expr :: rest when List.length remaining = List.length ea -> (
        let child_block = create_block re rest in        
        let e = child_block @ emit_expr context expr in
        let e = e @ (match expr with | Cexit _ -> [] | _ ->  [Br (I32.of_int_u (Stack.length block_stack - 1))]) in        
        e
        ); *)
      | _i :: re, expr :: rest -> (
        current_return_type := [];
        block_instruction 
          BCswitch_case
          (fun () -> 
            let child_block = create_block re rest in        
            let e = child_block @ emit_expr context expr in
            depth := !depth + 1;
            e @ (match expr with | Cexit _ -> [] | _ ->  [branch_call (Int32.of_int (List.length ea - !depth + 2)) !current_return_type])                                 
          )          
        @ (if (List.length ia = List.length remaining) then [Unreachable] else [])
      )
      | _, [] -> (
        current_return_type := [];
        block_instruction 
          BCswitch_main 
          (fun () -> 
            let tb = BrTable (List.map (fun f -> Int32.of_int (1 + f)) ia, 0l) in
            let e = emit_expr context sw in
            current_return_type := [];
            depth := !depth + 1;
            [Const (I32 1l)] @ e @ [Binary (I32 I32Op.Sub)] @ [tb];            
          )
      )
      | _ -> failwith "Should not happen..."
    in 
    block_instruction 
      BCswitch_container
      (fun () -> 
        let result = create_block ia ea in
        current_return_type := [I32Type];
        result
      )     
    )
  | Cloop e ->
    loop_instruction 
      (fun () -> 
        (emit_expr context e)
        @ [branch_call 0l []]
      )    
  | Ccatch  (_, with_, body) -> (          
    let rec create_block = function
      | (i, il, expr) :: rest -> (
        List.iter (fun i -> (
          (* type is always i32type which is incorrect, but maybe not significant.. maybe... *)
          ignore(bind_local context (i.Ident.name ^ "/" ^ string_of_int i.Ident.stamp) [I32Type])
        )) il; 
        current_return_type := [];
        block_instruction
          (BWith (i, (
            if !reset_top_ccatch then 
              ( print_endline "truth!";
                reset_top_ccatch := false;              
              true)
            else 
              false
          ), []))
          (fun () ->
            let child_block = create_block rest in
            let e  = child_block @ emit_expr context expr in    
            let top_block = Stack.top block_stack in 
            (match top_block with 
            | BWith (i, true, []) -> 
              (ignore(Stack.pop block_stack);
               Stack.push (BWith (i, true, !current_return_type)) block_stack)
            | _ -> ()
            );
            let top_ccatch = find_top_ccatch () in
            let length =        
              match top_ccatch with 
              | Some s -> s
              | None -> assert false
            in     
            let ct = ref !current_return_type in
            let result = add_additional_br e length !current_return_type in            
            (if length = 1 then   
              (
                let iter = ref 0 in
                Stack.iter (fun i -> 
                  (match i with 
                | BWith _ when !iter = 1 -> ct := []
                | BCcatch when !iter = 1 -> ct := []
                | _ -> ());
                iter := !iter + 1
                ) block_stack;


              current_return_type := !ct));
            result
          )
      )
      | [] ->
        block_instruction 
          BCcatch
          (fun () ->  
            emit_expr context body
          )
    in
    create_block with_)
  | Cexit (i, el) ->
    (
      current_return_type := [];
      let el = List.fold_left (fun all e ->
        all @ (emit_expr context e)
      ) [] el in
      let position = ref 0 in
      let result = ref [] in
      Stack.iter (fun str ->
        (match str with 
        | BWith (w, _, _) when w = i -> 
          result := [branch_call (Int32.of_int (!position - 1)) !current_return_type]
        | _ -> ());
        position := !position + 1
      ) block_stack;
      
      el @
      !result
    )
  | Ctrywith  (body, _exn, _handler) ->
    (
      (* fix later *)
      print_endline "Wrongly doing Ctrywith: always picking the body for now";
      (emit_expr context body)
      (* /Users/Sander/Projects/llvmwasm/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp *)
      (* let memory_alloc_size = ref 0 in
      VarMap.iter (fun _ (_, t) ->
        match t with
        | I32Type
        | F32Type -> memory_alloc_size := !memory_alloc_size + 4
        | I32Type
        | F64Type -> memory_alloc_size := !memory_alloc_size + 8
      ) context.locals.l_map;

      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let alloc_memory_pointer = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      
      let store_instructions = ref
      [Const (I32 (I32.of_int_s !memory_alloc_size));
       Call "caml_alloc";
       SetLocal alloc_memory_pointer
      ]
      in
      let set_blocks = ref [] in
      let get_blocks = ref [] in
      let memory_block_position = ref 4 in (* first block is reserved for the return value *)
      VarMap.iter (fun _ (value, t) ->
        set_blocks := !set_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> (
                [GetLocal value;
                 Store {ty = I32Type; align = 0; offset = 0l; sz = None}]
              )
            | F32Type -> (
                [GetLocal value;
                 Store {ty = F32Type; align = 0; offset = 0l; sz = None}]
              )
            | _ -> failwith "not supported"
          );
        get_blocks := !get_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> [Load {ty = I32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | F32Type -> [Load {ty = F32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | _ -> failwith "not supported"
          );
        (* match t with
          | I32Type
          | F32Type -> ( *)
          memory_block_position := !memory_block_position + 4;
            (* ) *)
          (* | _ -> assert false *)
      ) context.locals.l_map;
      let body_fn_id = create_exception_function context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_body") body in
      let exn_name = (exn.Ident.name ^ "_" ^ string_of_int exn.Ident.stamp) in
      let handler_fn_id = create_exception_function ~is_handler:true ~exn_name context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_handler") handler in
      
      current_return_type := [I32Type];
      !store_instructions @
      !set_blocks @
      [
      GetLocal alloc_memory_pointer;
      Const (I32 body_fn_id);
      Const (I32 handler_fn_id);
      Call "caml_alloc"] @
      !get_blocks @
      [ GetLocal alloc_memory_pointer;
        Load {ty = I32Type; align = 0; offset = 0l; sz = None}; (* TODO: also support float return value... *)
      ] *)
    )




let begin_assembly () = (
  let globals = [{
    name = "global_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s !global_offset))]
  };
  {
    name = "global_memory_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s 0))]
  }
  ]
  in
  let data = [{
    index =  0l;
    offset = [Const (I32 0l)];
    init = {
      name = "caml_globals_inited";
      detail = [Int8 0]
    };
  }; {
    index =  0l;
    offset = [Const (I32 1l)];
    init = {
      name = "caml_backtrace_pos";
      detail = [Int32 0l]
    };
  };
  ]
  in
  
  let w = !wasm_module in
  wasm_module := {w with symbols = w.symbols @ [{
    name = "caml_globals_inited";
    details = Data ({
      index = 0l;
      relocation_offset = 0l;
      size =  1l;
      offset = 0l;
    })
  };
  {
    name = "caml_backtrace_pos";
    details = Data ({      
      index = 1l;
      relocation_offset = 0l;
      size =  4l;
      offset = 1l;
    })
  };
  ]};

  global_offset := !global_offset + 5; (* TODO: make this a bit smarter (eg. count the previous sizes) *)

  let jsTryWithType:Ast.type_ = {name = "jsTryWithType"; details = Types.FuncType ([Types.I32Type;Types.I32Type;Types.I32Type], [])} in
  let type_:Ast.type_ = {name = "type_"; details = Types.FuncType ([Types.I32Type], [Types.I32Type])} in
  let empty_type:Ast.type_ = {name = "empty_type"; details = Types.FuncType ([], [])} in
  let raise_i32_unit:Ast.type_ = {name = "raise_i32_ftype"; details = Types.FuncType ([Types.I32Type], [])} in
  let types = [ jsTryWithType; type_; empty_type; raise_i32_unit] in
  
  let imports = [
    {
      module_name = name "js";
      item_name = name "tryWith";
      idesc = FuncImport "jsTryWithType"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_i32";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_unit";
      idesc = FuncImport "raise_i32_ftype"
    };
    {
      module_name = name "js";
      item_name = name "caml_fresh_oo_id";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "libasmrun";
      item_name = name "caml_alloc";
      idesc = FuncImport "type_"
    };
    (* {
      module_name = name "linking";
      item_name = name "camlCamlinternalFormatBasics__entry";
      idesc = FuncImport "empty_type"
    }; *)
    {
      module_name = name "linking";
      item_name = name "camlPervasives__entry";
      idesc = FuncImport "empty_type"
    };
  ]
  in

  
  create_import_symbol "jsTryWith" [] [];
  create_import_symbol "jsRaise_i32_i32" [] [];
  create_import_symbol "jsRaise_i32_unit" [] [];
  create_import_symbol "caml_fresh_oo_id" [] [];
  create_import_symbol "caml_alloc" [] [];
  (* create_import_symbol "camlCamlinternalFormatBasics__entry" [||]; *)
  create_import_symbol "camlPervasives__entry" [] [];

  let exports = [
  {
    name = name "table";
    edesc = TableExport 0l;
  };
  {
    name = name "memory";
    edesc = MemoryExport 0l;
  }
  ]
  in
  let w = !wasm_module in
  wasm_module := Ast.{w with
    globals = globals;
    types = types;
    data = data;
    imports = imports;
    exports = exports;
  };
)

(* let rec add_exception_functions ppf = (
  let _exception_fns = !exception_fns in
  exception_fns := [];
  List.iter (fun {name; expression; mem_pointer; locals; is_handler; exn_name} -> (
    let exn_name = match exn_name with
    | Some s -> s
    | _ -> ""
    in
    compile_wasm_phrase  ~locals ~is_handler ~exn_name ppf (Cfunction ({
      fun_name = name;
      fun_args = [];
      fun_body = expression;
      fun_codegen_options = [];
      fun_dbg = []
      }))
    )) _exception_fns;

) *)

let fundecl ({fun_name; fun_args; fun_body; _}) = ( 
    print_endline ("Function: " ^ fun_name);
    let context = enter_func () in
    let args = ref [] in
    List.iter (fun (ident, mt) ->
      let value_type = match mt with
      | [|Val|]
      | [|Addr|]
      | [|Int|] -> I32Type
      | [|Float|] -> F32Type
      | _ -> failwith "Unexpected combination of machtypes"
      in
      ignore(bind_local context (ident.Ident.name ^ "/" ^ string_of_int ident.Ident.stamp) [value_type]);
      args := [value_type] @ !args;      
    ) fun_args;
    
    create_func_symbol fun_name (0, 0);
    
    (* remove unit return value *)    
    current_return_type := [];
    let fun_body = emit_expr context fun_body in     
    if (Stack.length block_stack <> 0) then (
      failwith "Stack length doesn't equal 0 for some reason..."
    );
    let body = fun_body in

    let type_:Ast.type_ = {name = fun_name; details = Types.FuncType (!args, !current_return_type)} in
    let temp_locals = ref [] in
    VarMap.iter (fun _ (i, t, name) -> 
      temp_locals := !temp_locals @ [(i, name, t)]
    ) context.locals.l_map;
    let temp_locals = List.sort (fun (a, _, _) (b, _,_) -> 
      if (I32.gt_u a b) then 
        1 
      else if (I32.lt_u b a) then
        -1 
      else 
        0
    ) !temp_locals in
    let locals = List.map (fun (_, name, t) -> (name, List.hd t)) temp_locals in
    (* let i = ref 0 in *)
    (* let filtered = List.filter(fun _ -> 
      i := !i + 1;
      let t = !i - 1 in
      (if t < List.length !args then 
        false
      else 
        true)
    ) locals in *)
    let result = {
      name = fun_name;
      ftype = fun_name;
      locals = locals;
      body;
      no_of_args = List.length fun_args
    } in
    let export = {
      name = name fun_name;
      edesc = FuncExport fun_name;
    } in

    let w = !wasm_module in
    wasm_module := Ast.{w with funcs = w.funcs @ [result];
                               types = w.types @ [type_];
                               exports = w.exports @ [export];
                               };
)
and data dl = (
    if List.length dl > 0 && (List.exists (fun x -> 
    match x with 
    | Csymbol_address _ -> false
    | _ -> true
    ) dl) then (        
        let init = ref [] in
        let start_offset = !global_offset in
        (* let data_id = ref 0l in *)
        let offset = ref 0 in        
        let symbol_name = ref "" in
        let size = ref 0n in
        let is_closure =
            match List.hd dl with
            | Cint i when (((Nativeint.to_int i) land 255) == 247) -> 
              let (s, _) = blockheader_details i in
              size := s;
              true
            | Csymbol_address _ -> true
            | _ -> false
        in
        List.iter (function
        | Cglobal_symbol _ -> ()
        | Csymbol_address symbol -> (            
            let add =
              if is_closure then               
                ((if not (func_symbol_exists symbol) then (                  
                  create_import_symbol symbol [] [];
                  [FunctionLoc symbol] 
                  )
                  else 
                    [FunctionLoc symbol]
                  )
                )
              else  
                
                [Symbol symbol]
            in
            init := !init @ add;
            offset := !offset + 4;
            ()
            )
        | Cdefine_symbol symbol -> 
          symbol_name := symbol
        | Cint8 i -> (
            init := !init @ [Int8 i];
            offset := !offset + 1;
            ()
            )
        | Cint16 i -> (
            init := !init @ [Int16 i];
            offset := !offset + 2;
            ()
            )
        | Cint32 ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Cint ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Csingle d
        | Cdouble d -> (
            init := !init @ [Float32 (F32.of_float d)];
            offset := !offset + 4;
            ()
            )
        | Cstring s -> (
            init := !init @ [Ast.String s];
            offset := !offset + (String.length s);
            ()
            )
        | Cskip _ -> ()
        | Calign _ -> () (* seems not to be produced anyway in the OCaml codebase *)
        ) dl;

        let w = !wasm_module in
        wasm_module := {w with symbols = w.symbols @ [{
          name = !symbol_name;
          details = Data ({
              index = 0l;
              relocation_offset = 0l;
              size =  Int32.of_int !offset;
              offset = Int32.of_int start_offset
          })
        }]};
        
        let w = !wasm_module in

        global_offset := !global_offset + !offset;

        (* to make sure that this is always seen as data and not an integer *)
        (if !global_offset land 1 <> 0 then global_offset := !global_offset + 1);
        wasm_module := Ast.{w with data = w.data @ [{
        index =  0l;
        offset = [Const (I32 (I32.of_int_s start_offset))];
        init = {
            name = !symbol_name;
            detail = !init
        }
        }];
    }
    )
)