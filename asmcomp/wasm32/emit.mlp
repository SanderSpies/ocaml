(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                             Sander Spies                               *)
(*                                                                        *)
(*   Copyright 2017 - 2018                                                *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* From C-- to webassembly bytecode *)

[@@@ocaml.warning "-20-27"]

open Cmm
open Ast
open Values
open Wasm_types

(*
  the basic webassembly constructs and functions are taken from the webassembly
  spec implementation with some modifications:
   - local_space added to keep info on the value_type of the local
   - errors are now failwith <- TODO fixme

   TODO: license!
 *)

module VarMap = Map.Make(String)

type space = {mutable map : int32 VarMap.t; mutable count : int32}

type local_space = {mutable l_map : (int32 * value_type) VarMap.t; mutable l_count : int32}

type block_stack = string Stack.t

(* the resulting wasm module *)
let wasm_module = ref {
  types = [];
  globals = [];
  tables = Types.[{
    ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
  }];
  memories = Types.[{
    (* TODO: this needs to be improved when doing GC *)
    mtype = MemoryType {min = 100l; max = Some 100l}
  }];
  funcs = [];
  start = None;
  elems = [];
  data = [];
  imports = [];
  exports = [];
  symbols = [];
}

let empty () = {map = VarMap.empty; count = 0l}

type types = {space : space; mutable list : type_ list}
let empty_types () = {space = empty (); list = []}
let empty_locals () = {l_map = VarMap.empty; l_count = 0l};
type context =
  { data: space; types : types; tables : space; memories : space;
    funcs : space; locals : local_space; globals : space; labels : int32 VarMap.t }

let empty_context () =
  { data = empty (); types = empty_types (); tables = empty (); memories = empty ();
    funcs = empty (); locals = empty_locals(); globals = empty ();
    labels = VarMap.empty }

let block_stack : block_stack = Stack.create ()

let lookup category space x =
  VarMap.find x space.map

let lookup_local category space x =
  VarMap.find x space.l_map

(* let type_ (c : context) x = lookup "type" c.types.space x *)
let data2 (c : context) x = lookup "data" c.data x
let local (c : context) x = lookup_local "local" c.locals x
let global (c : context) x = lookup "global" c.globals x

let context = ref (empty_context ())

let bind category space x =
  if VarMap.mem x space.map then
    failwith ("Duplicate:" ^ x);
  let i = space.count in
  space.map <- VarMap.add x space.count space.map;
  space.count <- Int32.add space.count 1l;
  if space.count = 0l then
    failwith "Too many bindings";
  i

let bind_local category (space:local_space) x value_type =
  if VarMap.mem x space.l_map then
    failwith ("Duplicate:" ^ x);
  let i = space.l_count in
  space.l_map <- VarMap.add x (space.l_count, value_type) space.l_map;
  space.l_count <- Int32.add space.l_count 1l;
  if space.l_count = 0l then
    failwith "Too many bindings";
  i

let bind_type (c : context) x ty =
  c.types.list <- c.types.list @ [ty];
  bind "type" c.types.space x

(* let func_symbol_exists symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import when name = symbol -> true
    | Function when name = symbol -> true        
    | _ -> false
  ) w.symbols *)

let create_func_symbol name = 
  let w = !wasm_module in
  wasm_module := {w with 
    symbols = w.symbols @ [{
      name = name;
      details = Function
    }]
  }

let create_import_symbol name = 
  let w = !wasm_module in
  wasm_module := {w with 
    symbols = w.symbols @ [{
      name = name;
      details = Import
    }]
  }

let bind_func (c : context) x = (  
  bind "function" c.funcs x  
)

let create_symbol_table () = (
  let w = !wasm_module in
  let global_symbols = (List.mapi (fun i (g:Ast.global) -> 
    {
    name = g.name;
    details = Global ({
      index = Int32.of_int i;      
    })
  }) w.globals)
  in
  wasm_module := {w with
    symbols =
      w.symbols @ global_symbols 
  }
)

let bind_local (c : context) name value_type = bind_local "local" c.locals name value_type
let bind_data (c : context) x i = (
  let space = c.data in
  if VarMap.mem x space.map then
    failwith ("Duplicate:" ^ x);
  space.map <- VarMap.add x i space.map;
  space.count <- Int32.add space.count 1l;
  if space.count = 0l then
    failwith "Too many bindings";
  i
)
let bind_global (c : context) x = bind "global" c.globals x

let func (c : context) x =
  try
    let result = lookup "function" c.funcs x in
    result
  with
    | Not_found -> failwith ("Not found function:" ^ x)

let current_return_type = ref []

let enter_func (c : context) = (
  current_return_type := [];
  {c with labels = VarMap.empty; locals = empty_locals()}
)

(* custom implementation *)

let unique_name_counter = ref 0
let data_index = ref 0

let name s =
  try Utf8.decode s with Utf8.Utf8 ->
    failwith "invalid UTF-8 encoding"

let turn_missing_functions_to_imports () = (
  let context = !context in
  let w = !wasm_module in
  let missing_imports = List.filter Ast.(fun symbol ->
    match symbol.details with 
    | Function
    | Import  -> (
      let key = symbol.name in
      not (List.exists (fun (i:Ast.import) -> (Ast.string_of_name i.item_name) = key) w.imports)
      &&
      not (List.exists (fun (f:Ast.func) -> f.name = key) w.funcs)
    )
    | _ -> false    
  ) w.symbols in  
  let imports = ref [] in
  let type_ = ref (-1l) in
  List.iter (fun symbol ->
    let key = symbol.name in
    (* create a temp empty type... *)
    (* TODO: refactor... *)
    let empty_type = Types.FuncType ([], []) in
    let empty_ftype = bind_type context ("empty_type_" ^ key) empty_type in
    type_ := empty_ftype;
    let w = !wasm_module in
    wasm_module := Ast.{w with types = w.types @ [empty_type]};
    imports := !imports @ [{
      module_name = name "libasmrun";
      item_name = name key;
      idesc = FuncImport empty_ftype
    }];
  ) missing_imports;
  let w = !wasm_module in
  wasm_module := Ast.{w with imports = w.imports @ !imports}
)

let global_offset = ref 0

let add_missing_memory_addresses () = (
  let w = !wasm_module in
  List.iter (fun (s:data_part segment) -> 
    List.iter (fun d -> 
      match d with 
      | Symbol symbol -> (
          let has_symbol = List.find_opt (fun (x:data_part segment) ->
            x.init.name = symbol
          ) w.data 
          in 
          match has_symbol with 
          | Some _ -> ()
          | _ -> (    
            let w = !wasm_module in       
            wasm_module := {w with symbols = w.symbols @ 
              [{
                name = symbol;
                details = Data ({
                    index = (-1l);
                    relocation_offset = 0l;
                    size = 0l;
                    offset = 0l
                })
              }]
            };
            data_index := !data_index + 1;           
          )
        )
      | _ -> ()
    ) s.init.detail    
  ) w.data
)
  

let end_assembly () = (
  turn_missing_functions_to_imports ();
  add_missing_memory_addresses ();
  create_symbol_table ();
  Encode.encode !wasm_module;  
  wasm_module := {
    types = [];
    globals = [];
    tables = Types.[{
      ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
    }];
    memories = Types.[{
      (* TODO: this needs to be improved when doing GC *)
      mtype = MemoryType {min = 100l; max = Some 100l}
    }];
    funcs = [];
    start = None;
    elems = [];
    data = [];
    imports = [];
    exports = [];
    symbols = [];
  };
  context := empty_context ();
  current_return_type := [];
  data_index := 0;
)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(_s, ty, _alloc, _) -> ty
  | Cload (c, _) ->
      begin match c with
      | Word_val -> typ_val
      | Single | Double | Double_u -> typ_float
      | _ -> typ_int
      end
  | Calloc -> typ_val
  | Cstore (_c, _) -> typ_void
  | Caddi | Csubi | Cmuli | Cmulhi | Cdivi | Cmodi |
    Cand | Cor | Cxor | Clsl | Clsr | Casr |
    Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Caddv -> typ_val
  | Cadda -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise _ -> typ_void
| Ccheckbound -> typ_void

let convert_result = function 
   | [||] -> []   
   | [|Float|] -> [F32Type]   
   | [|Val|]
   | [|Addr|]
   | [|Int|] -> [I32Type]
   | _ -> assert false

(* let oper_result_type = function
  | Capply _ -> [I32Type]
  | Cextcall _ -> [I32Type]
  | Cload (c, _) ->
    begin match c with
    | Word_val -> [I32Type]
    | Single | Double | Double_u -> [F32Type]
    | _ -> [I32Type]
    end
  | Calloc -> [I32Type]
  | Cstore _ -> []
  | Caddi | Csubi | Cmuli | Cmulhi | Cdivi | Cmodi |
  Cand | Cor | Cxor | Clsl | Clsr | Casr |
  Ccmpi _ | Ccmpa _ | Ccmpf _ -> [I32Type]
  | Caddv -> [I32Type]
  | Cadda -> [I32Type]
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> [F32Type]
  | Cfloatofint -> [F32Type]
  | Cintoffloat -> [I32Type]
  | Craise _ -> [I32Type]
  | Ccheckbound -> []
 *)


(*
  exceptions are tricky for now as wasm doesn't support it.

  Right now it works as follows:
  - within JS we raise and catch exceptions
  - the tryWith body and handler are turned into separate functions white_closure_header
    are called from JavaScript

  - there is probably a bug or 2 in this code
*)
type exception_fn = {
  name: string;
  expression: expression;
  mem_pointer: int32;
  locals: (string * value_type) list;
  is_handler: bool;
  exn_name: string option
}

let exception_fns:((exception_fn list) ref) = ref []
let create_exception_function ?is_handler:(is_handler = false) ?exn_name (context:context) mem_pointer (name: string) (instr:expression) = (
    let fn_id = bind_func context name in
    let (st:((string * value_type) list) ref) = ref [] in
    VarMap.iter (fun key (value, t) -> st := !st @ [(key, t)]) context.locals.l_map;
    let e_fn = {
      name = name;
      expression = instr;
      mem_pointer = mem_pointer;
      locals = !st;
      is_handler = is_handler;
      exn_name
    }
    in
    exception_fns := !exception_fns @ [e_fn];
    fn_id
)

let blockheader_details header =
    let word_size = Nativeint.shift_right header 10 in
    let tag = (Nativeint.logand header 255n) in
    (word_size, tag)

let size_expr exp =
  let rec size = function
      Cconst_int _ | Cconst_natint _ -> Arch.size_int
    | Cconst_symbol _ -> Arch.size_addr
    | Cconst_float _ -> Arch.size_float
    | Cblockheader _ -> Arch.size_int
    | Cvar id -> 4
      (* failwith "todo" *)
        (* begin try
          Tbl.find id localenv
        with Not_found ->
        try
          let regs = env_find id env in
          size_machtype (Array.map (fun r -> r.typ) regs)
        with Not_found ->
          fatal_error("Selection.size_expr: unbound var " ^
                      Ident.unique_name id)
        end *)
    | Ctuple el ->
        List.fold_right (fun e sz -> size e + sz) el 0
    | Cop(op, _, _) ->
        Cmm.size_machtype(oper_result_type op)
    | Clet(id, arg, body) ->
        4
        (* failwith "todo 2" *)
        (* size (Tbl.add id (size localenv arg) localenv) body *)
    | Csequence(_e1, e2) ->
        size e2
    | _ -> 4
        (* failwith "Selection.size_expr" *)
  in size exp 


let rec to_operations context (expression_list:expression list) operation =
  let result = (match operation, expression_list with
  | Capply _, _ -> failwith "!!! This apply is not handled correctly !!!"
  | Cextcall (symbol, mt, b, l), _ -> (
      let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
      expression_list @
      try 
        ignore(bind_func context symbol);
        create_import_symbol symbol;
        [Call symbol]
      with 
      | _ -> 
        ignore(func context symbol);
        [Call symbol]
    )
  | Cload (memory_chunk, mutable_flag), _ -> (
      let align = 0 in
      let offset = 0l in
      let instr = Ast.Types.(match memory_chunk with
      | Byte_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, ZX)}]
      | Byte_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, SX)}]
      | Sixteen_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, ZX)}]
      | Sixteen_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, SX)}]
      | Thirtytwo_unsigned -> [Load {ty = I32Type; align; offset; sz = None}]
      | Thirtytwo_signed -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_int -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_val -> [Load {ty = I32Type; align; offset; sz = None}]
      | Single -> [Load {ty = I32Type; align; offset; sz = None}]

      (* for now we are targetting the 32bit version of wasm, in the future
         there might be a 64bit version *)
      | Double -> [Load {ty = F32Type; align; offset; sz = None}]
      | Double_u -> [Load {ty = F32Type; align; offset; sz = None}])
      in
      let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
      expression_list @ instr
    )
  | Calloc, Cblockheader (header, _) :: _ -> (
      let (word_size, tag) = blockheader_details header in
      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let local_ = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      let position = ref 0 in
      

      let calls = List.fold_left (fun calls f ->         
        let result = calls @
        ([GetLocal local_;
        Const (I32 (I32.of_int_s !position));
        Binary (I32 I32Op.Add)]
        @
        (match f with 
        | Cconst_symbol symbol -> (
          try 
          ignore(data2 context symbol);
          [DataSymbol symbol]
        with
        | _ -> 
          ignore(bind_data context symbol (-1l));
          [DataSymbol symbol]
        )
        | _ as e -> emit_expr context e)
        @
        match !current_return_type with 
        | [I32Type] -> [Store {ty = Types.I32Type; align = 0; offset = 0l; sz = None}]
        | [F32Type] -> [Store {ty = Types.F32Type; align = 0; offset = 0l; sz = None}]
        | _ -> print_endline "Not a proper solution..."; [Store {ty = Types.I32Type; align = 0; offset = 0l; sz = None}])
        in
        position := !position + size_expr f;
        result
      ) [] expression_list
      in      
      ignore(func context "caml_alloc");
      let result = [Const (I32 (Nativeint.to_int32 word_size));
       Call "caml_alloc";
       SetLocal local_
      ]
      @
      calls
      @
      [GetLocal local_; (* return the value after the OCaml block header *)
       Const (I32 4l);
       Binary (I32 I32Op.Add)
      ]
      in 
      result
    )
  | Cstore (memory_chunk, initialization_or_assignment), _ ->
    let align = 0 in
    let offset = 0l in
    let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] expression_list in
    let instr = Ast.Types.(match memory_chunk with
    | Byte_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Byte_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Sixteen_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Sixteen_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Thirtytwo_unsigned -> [Store {ty = I32Type; align; offset; sz = None}]
    | Thirtytwo_signed -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_int -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_val -> [Store {ty = I32Type; align; offset; sz = None}]
    | Single -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double_u -> [Store {ty = F32Type; align; offset; sz = None}])
    in
    current_return_type := [];
    expression_list @ instr
  | Cadda, [fst; snd] -> (* derived heap pointer *)
    let result = (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
    in
    result
  | Caddv, [fst; snd] -> (* pointer addition that produces a [Val] (well-formed Caml value) *)
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
  | Caddi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Add)]
  | Csubi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Sub)]
  | Cmuli, [fst; snd]
  | Cmulhi, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Mul)]
  | Cdivi, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
   [Binary (I32 I32Op.DivS)]
  | Cmodi, [fst; snd] ->
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let cmod_local = bind_local context ("cmod_" ^ string_of_int counter) I32Type in
    let cmod_local2 = bind_local context ("cmod2_" ^ string_of_int counter) I32Type in
    (emit_expr context fst) @
     [SetLocal cmod_local;
      GetLocal cmod_local;
      GetLocal cmod_local] @
     (emit_expr context snd) @
     [TeeLocal cmod_local2;
      Binary (I32 I32Op.DivS);
      GetLocal cmod_local2;
      Binary (I32 I32Op.Mul);
      Binary (I32 I32Op.Sub)]
  | Cand, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.And)]
  | Cor, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Or)]
  | Cxor, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (I32 I32Op.Xor)]
  | Clsl, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.Shl)]
  | Clsr, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.ShrU)]
  | Casr, [fst; snd] ->
  (emit_expr context fst) @
   (emit_expr context snd) @
     [Binary (I32 I32Op.ShrS)]
  | Ccmpi Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpi Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]
  | Ccmpi Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]
  | Ccmpi Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpi Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]
  | Ccmpi Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]
  | Caddv, _ -> failwith "caddv" (* pointer addition that produces a [Val] (well-formed Caml value) *)
  (* pointer addition that produces a [Addr] (derived heap pointer) *)
   | Ccmpa Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpa Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]
  | Ccmpa Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]
  | Ccmpa Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpa Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]
  | Ccmpa Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]
  | Cnegf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Neg)]
  | Cabsf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Abs)]
  | Caddf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Add)]
  | Csubf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Sub)]
  | Cmulf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Mul)]
  | Cdivf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Div)]
  | Cfloatofint, [fst] ->
    (emit_expr context fst) @
     [Convert (F32 F32Op.ReinterpretInt)]
  | Cintoffloat, [fst] ->
    (emit_expr context fst) @
     [Convert (I32 I32Op.ReinterpretFloat)]
  | Ccmpf CFeq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Eq)]
  | Ccmpf CFneq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ne)]
  | Ccmpf CFlt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Lt)]
  | Ccmpf CFnlt, [fst; snd] ->
    failwith "Not supported yet"
  | Ccmpf CFngt, [fst; snd] ->
    failwith "Not supported yet"
  | Ccmpf CFnle, [fst; snd] ->
    failwith "Not supported yet"
  | Ccmpf CFnge, [fst; snd] ->
    failwith "Not supported yet"
  | Ccmpf CFle, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Le)]
  | Ccmpf CFgt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Gt)]
  | Ccmpf CFge, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ge)]
  | Craise _, [arg] ->
    ignore(func context "jsRaise_i32_i32");
    (emit_expr context arg)
    @
    [Call "jsRaise_i32_i32"]
  | Ccheckbound, [fst; snd] -> (
    let fst = (emit_expr context fst) in
    let snd = (emit_expr context snd) in
    let if_ = fst @ snd @ [Compare (I32 I32Op.LtS)] in
    let else_ = snd @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)] in

    ignore(func context "jsRaise_i32_unit");
    if_ @ [If ([], [
      DataSymbol "caml_exn_Invalid_argument";
      Call "jsRaise_i32_unit"
    ],else_ @ [If ([], [
        DataSymbol "caml_exn_Invalid_argument";
        Call "jsRaise_i32_unit"
      ], [])])]
    )
  | _ -> failwith ("Something is not handled here   ... :" ^ string_of_int (List.length expression_list)))
  in
  current_return_type := convert_result (oper_result_type operation);
  result
and emit_expr (context:context) (expression:expression) =
  match expression with
  | Cconst_int i ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s i))]
  | Cconst_natint i ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cconst_float s ->
    current_return_type := [F32Type];
    [Const (F32 (F32.of_float s))]
  | Cconst_symbol symbol ->
    (
    try
      let (res, t) = local context symbol in
      current_return_type := [t];
      [Call symbol]
    with
    | _ -> try
      current_return_type := [I32Type];
      ignore(global context symbol);
      [Call symbol]
    with
    | _ -> try (
      ignore(func context symbol);
      [Call symbol]
    )
    with
    | _ -> try
      ignore(data2 context symbol);
      current_return_type := [I32Type];
      [
        DataSymbol symbol;
        Const (I32 4l);
        Binary (I32 I32Op.Add)
      ]
    with
    | _ -> 
      ignore(bind_data context symbol (-1l));
      current_return_type := [I32Type];
      [DataSymbol symbol;
       Const (I32 4l);
       Binary (I32 I32Op.Add)]
    )
 (* | Zonst (I32 (Nativeint.to_int32 i))] *)
  | Cblockheader (i, _) ->
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cvar ident ->
    (try (
      let (var, t) = local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) in
      current_return_type := [t];
      [GetLocal var]
    )
    with
    | _ ->
      failwith ("Cvar not found: " ^ ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp)
    )
  | Clet (ident, arg, fn_body) -> (
    let binding_name = ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp in
    let let_id = bind_local context binding_name I32Type in
    let result = emit_expr context arg in
    current_return_type := [];
    let body = emit_expr context fn_body in

    let result = if result = [] then (
      failwith "Clet - unexpected empty result";
    )
    else result
    in
    let result = result
    @
    [SetLocal let_id]
    @
    body
    in
    result
    )
  | Cassign (i, e) -> ( (* not tested yet, might be wrong... *)
      let (l, _) = local context (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) in
      let e = emit_expr context e in
      current_return_type := [];
      e @
      [SetLocal l]
    )
  | Ctuple el ->
    List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] el
  | Cop (Capply mt, (Cop (Cload _ as op, el, _))::tl, _) -> (
    let fn_args = ref [] in
    let expression_list = List.fold_left (fun lst f ->
      let result = emit_expr context f in
      fn_args := !fn_args @ !current_return_type;
      if List.length result > 0 then (
        lst @ result
      )
      else
        lst
    ) [] tl in
    let load_action = to_operations context el op in
    let type_ = FuncType (!fn_args, [I32Type]) in
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let ftype = bind_type context ("wasm_unique_name_" ^ string_of_int counter) type_ in
    let w = !wasm_module in
    wasm_module := Ast.{w with types = w.types @ [type_]};
    expression_list @
    load_action @
    [CallIndirect ftype]
    )
  | Cop (Capply _, (Cconst_symbol hd)::tl, _) -> (    
    let expression_list = List.fold_left (fun lst f -> lst @ (emit_expr context f)) [] tl in
    expression_list @
    try (
      ignore(func context hd);
      [Call hd] )
      with | _ ->
      ignore(bind_func context hd);
      print_endline ("Importing: " ^ hd);
      create_import_symbol hd;
      [Call hd]
    )
  | Cop (operation, expression_list, _) ->
    to_operations context expression_list operation
  | Csequence (e1, e2) ->
    let a = emit_expr context e1 in
    let b = emit_expr context e2 in
    a @ b
  | Cifthenelse (if_, then_, else_) ->
    Stack.push "ifthenelse" block_stack;
    let i = emit_expr context if_ in
    current_return_type := [];
    let t = emit_expr context then_ in
    let e = emit_expr context else_ in
    ignore(Stack.pop block_stack);
    i @ [If (!current_return_type, t, e)]
  | Cswitch  (sw, ia, ea, _) -> (
    let rec create_block ints remaining =
      match ints, remaining with
      | i :: re, expr :: rest -> (
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block re rest in
        let e = child_block @ emit_expr context expr in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | _, [] -> (
        current_return_type := [];
        Stack.push (string_of_int (Array.length ia + 1)) block_stack;
        Stack.push (string_of_int (Array.length ia + 2)) block_stack;
        let tb = BrTable ((List.map (fun f -> Int32.of_int (2 + f)) (Array.to_list ia)), 1l) in
        let e = emit_expr context sw in
        let result = [Block(!current_return_type, [Block (!current_return_type, [Const (I32 2l)] @ e @ [Binary (I32 I32Op.Sub)] @ [tb])]);] in
        ignore(Stack.pop block_stack);
        ignore(Stack.pop block_stack);
        result
      )
      | _ -> failwith "Should not happen..."
    in create_block (Array.to_list ia) (Array.to_list ea)
    )
  | Cloop e ->
    Stack.push "loop" block_stack;
    let expr = emit_expr context e in
    ignore(Stack.pop block_stack);
    let expr = expr @ [Br 0l] in
    [Loop ([], expr)]
  | Ccatch  (rf, with_, body) -> (     
    let rec create_block = function
      | (i, il, expr) :: rest -> (
        List.iter (fun i -> (
          (* type is always i32type which is incorrect, but maybe not significant.. maybe... *)
          ignore(bind_local context (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) I32Type);
        )) il; 
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block rest in
        let e = child_block @ emit_expr context expr in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | [] ->
        current_return_type := [];
        let e = emit_expr context body in
        [Block (!current_return_type, e)]
    in
    let blocks = create_block with_ in
    let temp_local = ref (-1l) in
    let rec fix_blocks depth result = function
    | Block (rt, el) :: remaining -> (
        if (depth = -1 && List.length rt > 0) then (
          let counter = !unique_name_counter in
          unique_name_counter := !unique_name_counter + 1;
          temp_local := bind_local context ("return_value_" ^ string_of_int counter) (List.nth rt 0)
        );
        fix_blocks depth (result @ [Block ([], fix_blocks (depth + 1) [] el)]) remaining
      )
    | If (crt, t, e) :: remaining -> (
        fix_blocks depth (result @ [If ([], fix_blocks (depth + 1) [] t, fix_blocks (depth + 1) [] e)]) remaining
      )
    | Loop ([], e) :: remaining -> (
      fix_blocks depth (result @ [Loop ([], fix_blocks (depth + 1) [] e)]) remaining
      )
    | _ as item :: remaining -> (
      let add = (match item with
      | BrTable _
      | Br _ -> []
      | _ ->
        if List.length remaining = 0 then (
            [SetLocal !temp_local; Br (Int32.of_int depth)]
          )
          else
            []
        )
      in
      fix_blocks depth (result @ [item] @ add) remaining
    )
    | [] -> result
    in
    let f = (fix_blocks (-1) [] blocks) in
    let x = if !temp_local <> (-1l) then
      [GetLocal !temp_local]
    else
      []
    in
    f @ x)
  | Cexit (i, el) ->
    (
      let el = List.fold_left (fun all e ->
        all @ (emit_expr context e)
      ) [] el in
      let position = ref 0 in
      let result = ref [] in
      Stack.iter (fun str ->
        position := !position + 1;
        if str = string_of_int i then (
          result := [Br (Int32.of_int (!position - 1))]
        )
      ) block_stack;
      el @
      !result
    )
  | Ctrywith  (body, exn, handler) ->
    (
      let memory_alloc_size = ref 0 in
      VarMap.iter (fun key (value, t) ->
        match t with
        | I32Type
        | F32Type -> memory_alloc_size := !memory_alloc_size + 4
        | I64Type
        | F64Type -> memory_alloc_size := !memory_alloc_size + 8
      ) context.locals.l_map;

      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let alloc_memory_pointer = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      ignore(func context "caml_alloc");
      let store_instructions = ref
      [Const (I32 (I32.of_int_s !memory_alloc_size));
       Call "caml_alloc";
       SetLocal alloc_memory_pointer
      ]
      in
      let set_blocks = ref [] in
      let get_blocks = ref [] in
      let memory_block_position = ref 4 in (* first block is reserved for the return value *)
      VarMap.iter (fun key (value, t) ->
        set_blocks := !set_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> (
                [GetLocal value;
                 Store {ty = I32Type; align = 0; offset = 0l; sz = None}]
              )
            | F32Type -> (
                [GetLocal value;
                 Store {ty = F32Type; align = 0; offset = 0l; sz = None}]
              )
            | _ -> failwith "not supported"
          );
        get_blocks := !get_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> [Load {ty = I32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | F32Type -> [Load {ty = F32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | _ -> failwith "not supported"
          );
        (* match t with
          | I32Type
          | F32Type -> ( *)
          memory_block_position := !memory_block_position + 4;
            (* ) *)
          (* | _ -> assert false *)
      ) context.locals.l_map;
      let body_fn_id = create_exception_function context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_body") body in
      let exn_name = (exn.Ident.name ^ "_" ^ string_of_int exn.Ident.stamp) in
      let handler_fn_id = create_exception_function ~is_handler:true ~exn_name context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_handler") handler in
      ignore (func context "caml_alloc");
      current_return_type := [I32Type];
      !store_instructions @
      !set_blocks @
      [
      GetLocal alloc_memory_pointer;
      Const (I32 body_fn_id);
      Const (I32 handler_fn_id);
      Call "caml_alloc"] @
      !get_blocks @
      [ GetLocal alloc_memory_pointer;
        Load {ty = I32Type; align = 0; offset = 0l; sz = None}; (* TODO: also support float return value... *)
      ]
    )




let begin_assembly () = (
  let context = !context in
  let globals = [{
    name = "global_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s !global_offset))]
  };
  {
    name = "global_memory_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s 0))]
  }
  ]
  in
  ignore(bind_global context "global_offset");
  ignore(bind_global context "global_memory_offset");

  let data = [{
    index =  0l;
    offset = [Const (I32 0l)];
    init = {
      name = "caml_globals_inited";
      detail = [Int8 0]
    };
  }; {
    index =  0l;
    offset = [Const (I32 1l)];
    init = {
      name = "caml_backtrace_pos";
      detail = [Int32 0l]
    };
  };
  ]
  in
  ignore(bind_data context "caml_globals_inited" 0l);
  ignore(bind_data context "caml_backtrace_pos" 1l);
  data_index := 2;
  let w = !wasm_module in
  wasm_module := {w with symbols = w.symbols @ [{
    name = "caml_globals_inited";
    details = Data ({
      index = 0l;
      relocation_offset = 0l;
      size =  1l;
      offset = 0l;
    })
  };
  {
    name = "caml_backtrace_pos";
    details = Data ({      
      index = 1l;
      relocation_offset = 0l;
      size =  4l;
      offset = 1l;
    })
  };
  ]};

  global_offset := !global_offset + 5;

  let jsTryWithType = Types.FuncType ([Types.I32Type;Types.I32Type;Types.I32Type], []) in
  let type_ = Types.FuncType ([Types.I32Type], [Types.I32Type]) in
  let empty_type = Types.FuncType ([], []) in
  let raise_i32_unit = Types.FuncType ([Types.I32Type], []) in
  let types = [ jsTryWithType; type_; empty_type; raise_i32_unit] in
  let jsTryWithType_ = bind_type context "jsTryWithType" jsTryWithType in
  let type__ftype = bind_type context "type_" type_ in
  let empty_ftype = bind_type context "empty_type" empty_type in
  let raise_i32_ftype = bind_type context "raise_i32_ftype" raise_i32_unit in

  let imports = [
    {
      module_name = name "js";
      item_name = name "tryWith";
      idesc = FuncImport jsTryWithType_
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_i32";
      idesc = FuncImport type__ftype
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_unit";
      idesc = FuncImport raise_i32_ftype
    };
    {
      module_name = name "js";
      item_name = name "caml_fresh_oo_id";
      idesc = FuncImport type__ftype
    };
    {
      module_name = name "libasmrun";
      item_name = name "caml_alloc";
      idesc = FuncImport type__ftype
    };
    {
      module_name = name "linking";
      item_name = name "camlCamlinternalFormatBasics__entry";
      idesc = FuncImport empty_ftype
    };
    {
      module_name = name "linking";
      item_name = name "camlPervasives__entry";
      idesc = FuncImport empty_ftype
    };
  ]
  in

  ignore(bind_func context "jsTryWith");
  ignore(bind_func context "jsRaise_i32_i32");
  ignore(bind_func context "jsRaise_i32_unit");
  ignore(bind_func context "caml_fresh_oo_id");
  ignore(bind_func context "caml_alloc");
  ignore(bind_func context "camlCamlinternalFormatBasics__entry");
  ignore(bind_func context "camlPervasives__entry");

  create_import_symbol "jsTryWith";
  create_import_symbol "jsRaise_i32_i32";
  create_import_symbol "jsRaise_i32_unit";
  create_import_symbol "caml_fresh_oo_id";
  create_import_symbol "caml_alloc";
  create_import_symbol "camlCamlinternalFormatBasics__entry";
  create_import_symbol "camlPervasives__entry";

  let exports = [
  {
    name = name "table";
    edesc = TableExport 0l;
  };
  {
    name = name "memory";
    edesc = MemoryExport 0l;
  }
  ]
  in
  let tables = [{ttype = TableType ({min = context.funcs.count; max = Some context.funcs.count}, AnyFuncType)}]
  in
  let rec add_elems result i = 
    match i with 
    | i when i > 0 -> 
      add_elems (result @ [
      {
        index = 0l;
        offset=[Const (I32 (I32.of_int_s i))];
        init=[(I32.of_int_s i)]
      }]) (i - 1)
    | i when i = 0 -> result
    | _ -> assert false
  in
  let elems = add_elems [] (Int32.to_int context.funcs.count) in
  let w = !wasm_module in
  wasm_module := Ast.{w with
    globals = globals;
    types = types;
    data = data;
    imports = imports;
    exports = exports;
    tables = tables;
    elems = elems
  };
)

(* let rec add_exception_functions ppf = (
  let _exception_fns = !exception_fns in
  exception_fns := [];
  List.iter (fun {name; expression; mem_pointer; locals; is_handler; exn_name} -> (
    let exn_name = match exn_name with
    | Some s -> s
    | _ -> ""
    in
    compile_wasm_phrase  ~locals ~is_handler ~exn_name ppf (Cfunction ({
      fun_name = name;
      fun_args = [];
      fun_body = expression;
      fun_codegen_options = [];
      fun_dbg = []
      }))
    )) _exception_fns;

) *)

let fundecl ({fun_name; fun_args; fun_body; fun_codegen_options; fun_dbg}) = (    
    print_endline ("Function: " ^ fun_name);
    let context = !context in
    let context = enter_func context in
    let args = ref [] in
    List.iter (fun (ident, mt) ->
      let value_type = match mt with
      | [|Val|]
      | [|Addr|]
      | [|Int|] -> I32Type
      | [|Float|] -> F32Type
      | _ -> failwith "Unexpected combination of machtypes"
      in
      ignore(bind_local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) value_type);
      args := [Types.I32Type] @ !args;
    ) fun_args;

    create_func_symbol fun_name;
    let (func_id, place) = try (
      (bind_func context fun_name, false)      
    ) with
    | _ -> (
      print_endline ("Failed to create a symbol for:" ^ fun_name);
      (func context fun_name, true)
    )
    in    
    ignore(func_id);
    ignore(place);
    (* remove unit return value *)
    let rec remove_last_unit fun_body =
      match fun_body with            
      | Csequence (expr, Cconst_int 1) -> expr
      | Csequence (expr1, Csequence (a, b)) -> Csequence (expr1, remove_last_unit (Csequence (a, b)))
      | _ as e -> e
    in
    let fun_body = remove_last_unit fun_body in    
    let fun_body = emit_expr context fun_body in        
    let body = fun_body in
    let type_ = Types.FuncType (!args, !current_return_type) in
    let ftype = bind_type context fun_name type_ in
    let locals = ref []
    in
    VarMap.iter (fun _ (_, t) -> locals := !locals @ [t]) context.locals.l_map;
    let result = {
      name = fun_name;
      ftype;
      locals = !locals;
      body;
    } in
    let export = {
      name = name fun_name;
      edesc = FuncExport fun_name;
    } in

    let w = !wasm_module in
    wasm_module := Ast.{w with funcs = w.funcs @ [result];
                               types = w.types @ [type_];
                               exports = w.exports @ [export]};

    let w = !wasm_module in
    let table = List.hd w.tables in
    let tt = table.ttype in
    Types.(match tt with
    | TableType (limits, _) -> (
      let max = match limits.max with
      | Some s -> s
      | None -> 0l
      in
      wasm_module := Ast.{w with
        tables = [{ttype = TableType ({min = (Int32.add max 1l); max = Some (Int32.add max 1l)}, AnyFuncType)}];
        elems = w.elems @ [{
          index = 0l;
          offset=[Const (I32 (I32.of_int_s (List.length w.elems)))];
          init=[I32.of_int_s (List.length w.elems)]
        }]
      }
    ));
    ()
)
and data dl = (
    if List.length dl > 0 then (
        let context = !context in
        let init = ref [] in
        let start_offset = !global_offset in
        (* let data_id = ref 0l in *)
        let offset = ref 0 in
        let is_closure =
        (match (List.nth dl 0) with
        | Cint i when (((Nativeint.to_int i) land 255) == 247) -> true
        | _ -> false)
        in
        let symbol_name = ref "" in
        List.iter (function
        | Cglobal_symbol s -> ()
        | Csymbol_address symbol -> (
            
            let add = try
              ignore(func context symbol);
              [FunctionLoc symbol]
            with
            | _ -> try
              [Symbol symbol]
            with
            | _ ->(
            if is_closure then ( 
              ignore(bind_func context symbol);
              [FunctionLoc symbol]
            )
            else
              [Symbol symbol]
            )
            in
            init := !init @ add;
            offset := !offset + 4;
            ()
            )
        | Cdefine_symbol symbol -> (
            try (
                symbol_name := symbol;
                ignore(bind_data context symbol (I32.of_int_u (start_offset + !offset)))
            ) with
            | _ -> ignore(data2 context symbol);

            ()
            )
        | Cint8 i -> (
            init := !init @ [Int8 i];
            offset := !offset + 1;
            ()
            )
        | Cint16 i -> (
            init := !init @ [Int16 i];
            offset := !offset + 2;
            ()
            )
        | Cint32 ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Cint ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Csingle d
        | Cdouble d -> (
            init := !init @ [Float32 (F32.of_float d)];
            offset := !offset + 4;
            ()
            )
        | Cstring s -> (
            init := !init @ [Ast.String s];
            offset := !offset + (String.length s);
            ()
            )
        | Cskip i ->
            (* TODO *)
            ()
        | Calign i -> () (* seems not to be produced anyway in the OCaml codebase *)
        ) dl;

        (* print_endline ("Offset for " ^ !symbol_name ^ " = " ^ string_of_int start_offset); *)
        let w = !wasm_module in
        wasm_module := {w with symbols = w.symbols @ [{
          name = !symbol_name;
          details = Data ({
              index = Int32.of_int !data_index;
              relocation_offset = 0l;
              size =  Int32.of_int !offset;
              offset = Int32.of_int start_offset
          })
        }]};
        data_index := !data_index + 1;

        let w = !wasm_module in

        global_offset := !global_offset + !offset;

        (* to make sure that this is always seen as data and not an integer *)
        (if !global_offset land 1 <> 0 then global_offset := !global_offset + 1);
        wasm_module := Ast.{w with data = w.data @ [{
        index =  0l;
        offset = [Const (I32 (I32.of_int_s start_offset))];
        init = {
            name = !symbol_name;
            detail = !init
        }
        }];
    }
    )
)