(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                             Sander Spies                               *)
(*                                                                        *)
(*   Copyright 2017 - 2018                                                *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* From C-- to WebAssembly object file AST *)

open Cmm
open Ast
open Values
open Wasm_types

(*
  WebAssembly (wasm) is a secure stackmachine. It guarantees security by using 
  type safety for all variables, limiting memory access, and having no access 
  to the stack. 
  
  It's possible to hack around not having stack access, but it's probably wiser 
  to wait for the right additions in wasm to appear. Luckily this already being 
  worked on:
  - https://github.com/WebAssembly/exception-handling/blob/master/proposals/Level-1.md
  - https://github.com/WebAssembly/gc/pull/34 
  - https://github.com/WebAssembly/tail-call/blob/master/proposals/tail-call/Overview.md 

  The code is compiled to the wasm object file format, which is defined here: 
  https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md. This
  is required to be able to use LLVM's LLD to link the generated wasm binary 
  with other code that's compiled to wasm (from clang for example).
*)

module VarMap = Map.Make(String)

type local_space = {mutable l_map : (int32 * value_type * string) VarMap.t; mutable l_count : int32}

type block_stack = string Stack.t
(* type local_stack = value_type Stack.t *)

(* the resulting wasm module *)
let wasm_module = ref {
  types = [];
  globals = [];
  tables = Types.[{
    ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
  }];
  memories = Types.[{
    (* TODO: this needs to be improved when doing GC *)
    mtype = MemoryType {min = 100l; max = Some 100l}
  }];
  funcs = [];
  start = None;
  elems = [];
  data = [];
  imports = [];
  exports = [];
  symbols = [];
}

let empty_locals () = {l_map = VarMap.empty; l_count = 0l};

type context =
  { locals : local_space }

let empty_context () =
  { locals = empty_locals() }

let block_stack : block_stack = Stack.create ()

(* let local_stack : local_stack = Stack.create () *)

let lookup_local space x =
  VarMap.find x space.l_map

let local (c : context) x = 
  let result = lookup_local c.locals x in 
  result

let context = ref (empty_context ())

let bind_local (space:local_space) x value_type =
  if VarMap.mem x space.l_map then
    failwith ("Duplicate:" ^ x);
  let i = space.l_count in
  space.l_map <- VarMap.add x (space.l_count, value_type, x) space.l_map;
  space.l_count <- Int32.add space.l_count 1l;
  if space.l_count = 0l then
    failwith "Too many bindings";
  i

let func_symbol_exists symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import _ when name = symbol -> true
    | Function _ when name = symbol -> true        
    | _ -> false
  ) w.symbols

let is_import symbol = 
  let w = !wasm_module in
  List.exists (fun f -> 
    let name = f.name in
    match f.details with
    | Import _ when name = symbol -> true
    | _ -> false
  ) w.symbols

let create_func_symbol symbol mt = (* TODO: move to encode *)
  if symbol = "" then failwith "2 Name can't be empty";
  if not (func_symbol_exists symbol) then (    
    let w = !wasm_module in
    wasm_module := {w with 
      symbols = w.symbols @ [{
        name = symbol;
        details = Function (0, 0)
      }]
    }
  )
  else if is_import symbol then (
    let w = !wasm_module in
    wasm_module := {w with symbols = List.map (fun s -> (
      if (s.name = symbol) then
        {
        name = symbol;
        details = Function mt
      }
      
      else s
          )) w.symbols
    }
  )

let create_import_symbol name args result =
  if name = "" then failwith "Name can't be empty";  
  if not (func_symbol_exists name) then (    
    let w = !wasm_module in
    wasm_module := {w with 
      symbols = w.symbols @ [{
        name = name;
        details = Import (args, result)
      }]
    }
  )

let create_symbol_table () = ( (* TODO: move to encode *)
  let w = !wasm_module in
  let global_symbols = (List.mapi (fun i (g:Ast.global) -> 
    {
    name = g.name;
    details = Global ({
      index = Int32.of_int i;      
    })
  }) w.globals)
  in
  wasm_module := {w with
    symbols =
      w.symbols @ global_symbols 
  }
)

let bind_local (c : context) name value_type = bind_local c.locals name value_type

let current_return_type = ref []

let enter_func () = (
  current_return_type := [];
  {locals = empty_locals()}
)

let unique_name_counter = ref 0

let name s =
  try Utf8.decode s with Utf8.Utf8 ->
    failwith "invalid UTF-8 encoding"

let global_offset = ref 0

let end_assembly () = (  
  create_symbol_table (); (* Move to Encode *)
  Encode.encode !wasm_module;  
  wasm_module := {
    types = [];
    globals = [];
    tables = Types.[{
      ttype = TableType ({min = 0l; max = Some 0l}, AnyFuncType)
    }];
    memories = Types.[{
      (* TODO: this needs to be improved when doing GC *)
      mtype = MemoryType {min = 100l; max = Some 100l}
    }];
    funcs = [];
    start = None;
    elems = [];
    data = [];
    imports = [];
    exports = [];
    symbols = []; (* Move to Encode *)
  };
  context := empty_context ();
  current_return_type := [];  
)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(_s, ty, _alloc, _) -> ty
  | Cload (c, _) ->
      begin match c with
      | Word_val -> typ_val
      | Single | Double | Double_u -> typ_float
      | _ -> typ_int
      end
  | Calloc -> typ_val
  | Cstore (_c, _) -> typ_void
  | Caddi | Csubi | Cmuli | Cmulhi | Cdivi | Cmodi |
    Cand | Cor | Cxor | Clsl | Clsr | Casr |
    Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Caddv -> typ_val
  | Cadda -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise _ -> typ_int
| Ccheckbound -> typ_void

let convert_result = function 
   | [||] -> []   
   | [|Float|] -> [F32Type]   
   | [|Val|]
   | [|Addr|]
   | [|Int|] -> 
      [I32Type]
   | _ -> assert false

(*
  FIXME: Exceptions are completely broken at the moment!

  exceptions are tricky for now as wasm doesn't support it.

  Right now it works as follows:
  - within JS we raise and catch exceptions
  - the tryWith body and handler are turned into separate functions white_closure_header
    are called from JavaScript

  - there is probably a bug or 2 in this code
*)
(* type exception_fn = {
  name: string;
  expression: expression;
  mem_pointer: int32;
  locals: (string * value_type) list;
  is_handler: bool;
  exn_name: string option
} *)
(* 
let exception_fns:((exception_fn list) ref) = ref []
let create_exception_function ?is_handler:(is_handler = false) ?exn_name (context:context) mem_pointer (name: string) (instr:expression) = (
    let fn_id = (-1l) in
    let (st:((string * value_type) list) ref) = ref [] in
    VarMap.iter (fun key (_, t) -> st := !st @ [(key, t)]) context.locals.l_map;
    let e_fn = {
      name = name;
      expression = instr;
      mem_pointer = mem_pointer;
      locals = !st;
      is_handler = is_handler;
      exn_name
    }
    in
    exception_fns := !exception_fns @ [e_fn];
    fn_id
) *)

(* let print_local_stack prefix =
  print_string (prefix ^ " (");
  Stack.iter (fun f -> 
    match f with 
    | I32Type -> print_string "i32 "
    | I64Type -> print_string "i64 "
    | F32Type -> print_string "f32 "
    | F64Type -> print_string "f64 "
  ) local_stack;
  print_endline ")"

let push_local_stack a  =
  List.iter (fun kind -> 
    ignore(Stack.push kind local_stack)
  ) a

let pop_local_stack a =
  for _i=0 to a - 1 do 
    ignore(Stack.pop local_stack)
  done *)

let blockheader_details header =
    let word_size = Nativeint.shift_right header 10 in
    let tag = (Nativeint.logand header 255n) in
    (word_size, tag)

let rec to_operations  (context) (expression_list:expression list) (operation:Cmm.operation) : Ast.instr list =     
  let result = (match operation, expression_list with
  | Capply _, _ -> failwith "!!! This apply is not handled correctly !!!"
  | Cextcall (symbol, _mt, _, _), _ -> (            
      let (args, expression_list) = (List.fold_left (fun (lst:stack_type * Ast.instr list) f -> 
        let (args, expression_list) = lst in
        let expr = emit_expr context f in
        (* pop_local_stack 1; *)
        (args @ !current_return_type, expression_list @ expr)) ([], []) expression_list)
      in
      expression_list
      @
      (if not (func_symbol_exists symbol) then 
        (
          print_endline "Potentially wrong return type (always saying i32 which is BAD)";
          create_import_symbol symbol args [I32Type];
        [Call symbol])
      else
        [Call symbol])
      )
  | Cload (memory_chunk, _), [el1] -> (
      let align = 0 in
      let offset = 0l in
      (* ignore(Stack.pop local_stack); *)
      let instr = 
         (Ast.Types.(match memory_chunk with
      | Byte_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, ZX)}]
      | Byte_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem8, SX)}]
      | Sixteen_unsigned -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, ZX)}]
      | Sixteen_signed -> [Load {ty = I32Type; align; offset; sz = Some (Mem16, SX)}]
      | Thirtytwo_unsigned -> [Load {ty = I32Type; align; offset; sz = None}]
      | Thirtytwo_signed -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_int -> [Load {ty = I32Type; align; offset; sz = None}]
      | Word_val -> [Load {ty = I32Type; align; offset; sz = None}]
      | Single -> [Load {ty = I32Type; align; offset; sz = None}]

      (* for now we are targetting the 32bit version of wasm, in the future
         there might be a 64bit version *)
      | Double -> [Load {ty = F32Type; align; offset; sz = None}]
      | Double_u -> [Load {ty = F32Type; align; offset; sz = None}]))
      in
      let expression_list = (emit_expr context el1) in                
      (* ignore(Stack.push I32Type local_stack);   *)
      (* print_local_stack "Cload"; *)
      expression_list @ instr
    )
  | Calloc, Cblockheader (header, _) :: _ -> (
      let (word_size, tag) = blockheader_details header in
      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let local_ = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      let position = ref 0 in
      let calls = List.fold_left (fun calls f ->         
        let result = calls @
        ([GetLocal local_;
        Const (I32 (I32.of_int_s !position));
        Binary (I32 I32Op.Add)]
        @
        (match f with 
        | Cconst_symbol symbol ->           
          let is_closure = ((Nativeint.to_int tag) land 255) == 247 in
          (if is_closure then [FuncSymbol symbol] else [DataSymbol symbol]);
          
        | _ as e -> emit_expr context e)
        @
        [Store {ty = Types.I32Type; align = 0; offset = 0l; sz = None}])        
        in
        (* ignore(Stack.pop local_stack);         *)
        position := !position + Nativeint.to_int word_size;
        result
      ) [] expression_list
      in      
      let result = [Const (I32 (Nativeint.to_int32 word_size));
       Call "caml_alloc";
       SetLocal local_
      ]
      @
      calls
      @
      [GetLocal local_] (* return the value after the OCaml block header *)      
      in 
      (* Stack.push I32Type local_stack; *)
      (* print_local_stack "Calloc, Cblockheader (header, _) :: _ "; *)
      result
    )
  | Cstore (memory_chunk, _), [el1; el2] ->
    
    let align = 0 in
    let offset = 0l in
    let expression_list = (emit_expr context el1) @ (emit_expr context el2) in
    let instr = Ast.Types.(match memory_chunk with
    | Byte_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Byte_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem8}]
    | Sixteen_unsigned -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Sixteen_signed -> [Store {ty = I32Type; align; offset; sz = Some Mem16}]
    | Thirtytwo_unsigned -> [Store {ty = I32Type; align; offset; sz = None}]
    | Thirtytwo_signed -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_int -> [Store {ty = I32Type; align; offset; sz = None}]
    | Word_val -> [Store {ty = I32Type; align; offset; sz = None}]
    | Single -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double -> [Store {ty = F32Type; align; offset; sz = None}]
    | Double_u -> [Store {ty = F32Type; align; offset; sz = None}])
    in
    current_return_type := [];
    (* print_local_stack "Cstore"; *)
    expression_list @ instr
  | Caddv, [fst; snd] (* pointer addition that produces a [Val] (well-formed Caml value) *)    
  | Caddi, [fst; snd]    
  | Cadda, [fst; snd] -> (* derived heap pointer *)        
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Add)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cadd*"; *)
    result        
  | Csubi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Sub)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Csubi"; *)
    result        
  | Cmuli, [fst; snd]
  | Cmulhi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Mul)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cmul*"; *)
    result                
  | Cdivi, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.DivS)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cdivi"; *)
    result                
  | Cmodi, [fst; snd] ->
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let cmod_local = bind_local context ("cmod_" ^ string_of_int counter) I32Type in
    let cmod_local2 = bind_local context ("cmod2_" ^ string_of_int counter) I32Type in
    (emit_expr context fst) @
     [SetLocal cmod_local;
      GetLocal cmod_local;
      GetLocal cmod_local] @
     (emit_expr context snd) @
     [TeeLocal cmod_local2;
      Binary (I32 I32Op.DivS);
      GetLocal cmod_local2;
      Binary (I32 I32Op.Mul);
      Binary (I32 I32Op.Sub)]
  | Cand, [fst; snd] ->    
   let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.And)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    (* print_local_stack "Cand"; *)
    result
  | Cor, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Or)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result        
  | Cxor, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Xor)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result               
  | Clsl, [fst; snd] ->
  let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.Shl)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result              
  | Clsr, [fst; snd] ->
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.ShrU)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result            
  | Casr, [fst; snd] ->    
    let result = (emit_expr context fst) @
     (emit_expr context snd) @     
      [Binary (I32 I32Op.ShrS)]     
    in
    (* pop_local_stack 2; *)
    (* push_local_stack [I32Type]; *)
    result            
  | Ccmpi Ceq, [fst; snd] ->
    (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (I32 I32Op.Eq)]      
  | Ccmpi Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]      
  | Ccmpi Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]      
  | Ccmpi Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LeS)]
  | Ccmpi Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]      
  | Ccmpi Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GeS)]      
  | Caddv, _ -> failwith "caddv" (* pointer addition that produces a [Val] (well-formed Caml value) *)
  (* pointer addition that produces a [Addr] (derived heap pointer) *)
   | Ccmpa Ceq, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Eq)]
  | Ccmpa Cne, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.Ne)]      
  | Ccmpa Clt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.LtS)]      
  | Ccmpa Cle, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
      [Compare (I32 I32Op.LeS)]      
  | Ccmpa Cgt, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Compare (I32 I32Op.GtS)]      
  | Ccmpa Cge, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
      [Compare (I32 I32Op.GeS)]      
  | Cnegf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Neg)]
  | Cabsf, [fst] ->
    (emit_expr context fst) @
     [Unary (F32 F32Op.Abs)]
  | Caddf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Add)]
  | Csubf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Sub)]
  | Cmulf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Mul)]
  | Cdivf, [fst; snd] ->
    (emit_expr context fst) @
     (emit_expr context snd) @
     [Binary (F32 F32Op.Div)]
  | Cfloatofint, [fst] ->
    (emit_expr context fst) @
     [Convert (F32 F32Op.ReinterpretInt)]
  | Cintoffloat, [fst] ->
    (emit_expr context fst) @
     [Convert (I32 I32Op.ReinterpretFloat)]
  | Ccmpf CFeq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Eq)]
  | Ccmpf CFneq, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ne)]
  | Ccmpf CFlt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Lt)]
  | Ccmpf CFnlt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFngt, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnle, _ ->
    failwith "Not supported yet"
  | Ccmpf CFnge, _ ->
    failwith "Not supported yet"
  | Ccmpf CFle, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Le)]
  | Ccmpf CFgt, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Gt)]
  | Ccmpf CFge, [fst; snd] ->
   (emit_expr context fst) @
    (emit_expr context snd) @
    [Compare (F32 F32Op.Ge)]
  | Craise _, _ -> 
    print_endline "CRAISE NOT SUPPORTED YET :-(";
    [] (* FIX ME *)
    (* (emit_expr context arg)
    @
    [Call "jsRaise_i32_i32"] *)
  | Ccheckbound, [fst; snd] -> 
    let fst = (emit_expr context fst) in
    let snd = (emit_expr context snd) in    
    let if_ = fst @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)] in
    let else_ = snd @ [Const (I32 0l)] @ [Compare (I32 I32Op.LtS)] in    
    let result = if_ @ [If ([], [
      DataSymbol "caml_exn_Invalid_argument";
      Call "jsRaise_i32_unit"
    ],else_ @ [If ([], [
        DataSymbol "caml_exn_Invalid_argument";
        Call "jsRaise_i32_unit"
      ], [])])]
    in
    result    
  | _ -> failwith ("Something is not handled here   ... :" ^ string_of_int (List.length expression_list)))
  in
  current_return_type := convert_result (oper_result_type operation);  
  result
and emit_expr (context:context) (expression:expression) =
  match expression with
  | Cconst_int i -> 
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cconst_int"; *)
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s i))]
  | Cconst_natint i -> 
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cconst_natint"; *)
    current_return_type := [I32Type];
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cconst_float s ->
    (* Stack.push F32Type local_stack; *)
    (* print_local_stack "Cconst_float"; *)
    current_return_type := [F32Type];
    [Const (F32 (F32.of_float s))]
  | Cconst_symbol symbol ->
    (      
    try
      let (_, t, _) = local context symbol in
      current_return_type := [t];
      (* Stack.push t local_stack; *)
      (* print_local_stack "Cconst_symbol"; *)
      [Call symbol]
    with
    | _ -> 
      (current_return_type := [I32Type];      
      (* Stack.push I32Type local_stack; *)
      (* print_local_stack "Cconst_symbol"; *)
      [DataSymbol symbol]))
  | Cblockheader (i, _) ->
    current_return_type := [I32Type];
    (* Stack.push I32Type local_stack; *)
    (* print_local_stack "Cblockheader"; *)
    [Const (I32 (I32.of_int_s (Nativeint.to_int i)))]
  | Cvar ident ->
    (try (
      let (var, t, _) = local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) in
      
      current_return_type := [t];
      (* Stack.push t local_stack; *)
      (* print_local_stack "Cvar"; *)
      [GetLocal var]      
    )
    with
    | _ ->
      failwith ("Cvar not found: " ^ ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp)
    )
  | Clet (ident, arg, fn_body) -> (
    
    let binding_name = ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp in    
    let let_id = bind_local context binding_name I32Type in    
    
    let result = emit_expr context arg in
    
    current_return_type := [];
    let body = emit_expr context fn_body in
    let result = if result = [] then (
      failwith "Clet - unexpected empty result";
    )
    else result
    in
    (* Stack.push I32Type local_stack;     *)
    (* print_local_stack "Clet"; *)
    let result = result
    @
    [SetLocal let_id]
    @
    body
    in
    result
    )
  | Cassign (i, e) -> (
      let name = (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) in
      let (l, _, _) = local context name in
      let e = emit_expr context e in
      current_return_type := [];
      (* print_local_stack "Cassign"; *)      
      e @
      [SetLocal l]
    )
  | Ctuple ([Cop (Cload _, _, _) as _el; Cop (Cload _, _, _) as el2]) ->
    print_endline "For now we are always treating 64bit as 32bit - so ignoring the first 4 bytes";
    (* print_endline "ctuple"; *)
    (* TODO ensure we are properly loading 64 bit here... *)
    let result = emit_expr context el2 in    
    (* print_local_stack "Ctuple (64bit cload)"; *)
    result
    (* let result = (emit_expr context el) in 
    current_return_type := [I32Type];
    result @ [
     Const (I32 4l);
     Binary (I32 I32Op.Shl)] @
    (emit_expr context el2) @
    [
     Binary (I32 I32Op.Add)]     *)
  | Ctuple el ->
    let result = List.fold_left (fun lst f -> 
      lst @ (emit_expr context f)) [] el in
    (* print_local_stack "Ctuple"; *)
    result
    
  | Cop (Capply _, (Cop (Cload _ as op, el, _))::tl, _) -> (    
    let fn_args = ref [] in
    let expression_list = List.fold_left (fun lst f ->
      let result = emit_expr context f in
      (* ignore(Stack.pop local_stack); *)
      fn_args := !fn_args @ !current_return_type;
      if List.length result > 0 then (
        lst @ result
      )
      else
        lst
    ) [] tl in
    let load_action = to_operations context el op in
    let counter = !unique_name_counter in
    unique_name_counter := !unique_name_counter + 1;
    let name_ = "wasm_unique_name_" ^ string_of_int counter in
    let type_:Ast.type_ = {name = name_; details = FuncType (!fn_args, [I32Type])} in    
    let w = !wasm_module in
    wasm_module := Ast.{w with types = w.types @ [type_]};
    (* print_local_stack "Cop (Capply _, (Cop (Cload _ as op, el, _))::tl, _)"; *)
    expression_list @
    load_action @
    [CallIndirect name_]
    )
  | Cop (Capply _mt, (Cconst_symbol hd)::tl, _) -> (    
    let (args, expression_list) = List.fold_left (fun lst f -> 
      let (args, expression_list) = lst in      
      let expr = emit_expr context f in
      (* ignore(Stack.pop local_stack); *)
      (args @ !current_return_type, expression_list @ expr)) ([], []) tl 
      in
    (* (match mt with 
        | [|Val|]
        | [|Addr|]
        | [|Int|] -> Stack.push I32Type local_stack
        | [|Float|] -> Stack.push F32Type local_stack
        | [||] -> ()
        | _ -> assert false
      );
    print_local_stack "Cop (Capply _mt, (Cconst_symbol hd)::tl, _)"; *)
    expression_list @
    (if func_symbol_exists hd then    
      [Call hd]
    else (     
      create_import_symbol hd args [I32Type];
      [Call hd])
    ))
  | Cop (operation, expression_list, _) ->  
    to_operations context expression_list operation
  | Csequence (e1, e2) ->        
    let a = emit_expr context e1 in
    let b = emit_expr context e2 in
    (* print_local_stack "Csequence"; *)
    a @ b
  | Cifthenelse (if_, then_, else_) ->
    Stack.push "ifthenelse" block_stack;
    let i = emit_expr context if_ in
    (* pop_local_stack 1; *)
    current_return_type := [];
    let t = emit_expr context then_ in    
    let e = emit_expr context else_ in
    (* print_local_stack "Cifthenelse"; *)
    i @ [If (!current_return_type, t, e)]
  | Cswitch  (sw, ia, ea, _) -> (
    let rec create_block ints remaining =
      match ints, remaining with
      | i :: re, expr :: rest -> (
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block re rest in
        let e = child_block @ emit_expr context expr @ [Br (I32.of_int_u (Stack.length block_stack - 1))] in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | _, [] -> (
        current_return_type := [];
        Stack.push (string_of_int (Array.length ia + 1)) block_stack;
        Stack.push (string_of_int (Array.length ia + 2)) block_stack;
        let tb = BrTable ((List.map (fun f -> Int32.of_int (2 + f)) (Array.to_list ia)), 1l) in
        let e = emit_expr context sw in
        let result = [Block(!current_return_type, [Block (!current_return_type, [Const (I32 2l)] @ e @ [Binary (I32 I32Op.Sub)] @ [tb])]);] in
        ignore(Stack.pop block_stack);
        ignore(Stack.pop block_stack);
        result
      )
      | _ -> failwith "Should not happen..."
    in create_block (Array.to_list ia) (Array.to_list ea)
    )
  | Cloop e ->
    Stack.push "loop" block_stack;
    let expr = emit_expr context e in
    ignore(Stack.pop block_stack);
    let expr = expr @ [Br 0l] in
    [Loop ([], expr)]
  | Ccatch  (_, with_, body) -> (  
    let rec create_block = function
      | (i, il, expr) :: rest -> (
        List.iter (fun i -> (
          (* type is always i32type which is incorrect, but maybe not significant.. maybe... *)
          ignore(bind_local context (i.Ident.name ^ "_" ^ string_of_int i.Ident.stamp) I32Type)
        )) il; 
        current_return_type := [];
        Stack.push (string_of_int i) block_stack;
        let child_block = create_block rest in
        let e = child_block @ emit_expr context expr in
        ignore(Stack.pop block_stack);
        [Block (!current_return_type, e)]
      )
      | [] ->
        current_return_type := [];
        let e = emit_expr context body in
        [Block (!current_return_type, e)]
    in
    let blocks = create_block with_ in
    let temp_local = ref (-1l) in
    let rec fix_blocks depth result = function
    | Block (rt, el) :: remaining -> (
        if (depth = -1 && List.length rt > 0) then (
          let counter = !unique_name_counter in
          unique_name_counter := !unique_name_counter + 1;
          temp_local := bind_local context ("return_value_" ^ string_of_int counter) (List.nth rt 0)          
        );
        fix_blocks depth (result @ [Block ([], fix_blocks (depth + 1) [] el)]) remaining
      )
    | If (_, t, e) :: remaining -> (
        fix_blocks depth (result @ [If ([], fix_blocks (depth + 1) [] t, fix_blocks (depth + 1) [] e)]) remaining
      )
    | Loop ([], e) :: remaining -> (
      fix_blocks depth (result @ [Loop ([], fix_blocks (depth + 1) [] e)]) remaining
      )
    | _ as item :: remaining -> (
      let add = (match item with
      | BrTable _
      | Br _ -> []
      | _ ->
        if List.length remaining = 0 then (
            if !temp_local <> (-1l) then (
              [SetLocal !temp_local; Br (Int32.of_int depth)]
            )
            else (
              [Br (Int32.of_int depth)]
            )
          )
          else
            []
        )
      in
      fix_blocks depth (result @ [item] @ add) remaining
    )
    | [] -> result
    in
    let f = (fix_blocks (-1) [] blocks) in
    let x = if !temp_local <> (-1l) then
      [GetLocal !temp_local]
    else
      []
    in
    f @ x)
  | Cexit (i, el) ->
    (
      let el = List.fold_left (fun all e ->
        all @ (emit_expr context e)
      ) [] el in
      let position = ref 0 in
      let result = ref [] in
      Stack.iter (fun str ->
        position := !position + 1;
        if str = string_of_int i then (
          result := [Br (Int32.of_int (!position - 1))]
        )
      ) block_stack;
      el @
      !result
    )
  | Ctrywith  (body, _exn, _handler) ->
    (
      (* fix later *)
      print_endline "Wrongly doing Ctrywith: always picking the body for now";
      (emit_expr context body)
      (* /Users/Sander/Projects/llvmwasm/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp *)
      (* let memory_alloc_size = ref 0 in
      VarMap.iter (fun _ (_, t) ->
        match t with
        | I32Type
        | F32Type -> memory_alloc_size := !memory_alloc_size + 4
        | I32Type
        | F64Type -> memory_alloc_size := !memory_alloc_size + 8
      ) context.locals.l_map;

      let counter = !unique_name_counter in
      unique_name_counter := !unique_name_counter + 1;
      let alloc_memory_pointer = bind_local context ("allocate_memory_pointer_" ^ string_of_int counter) I32Type in
      
      let store_instructions = ref
      [Const (I32 (I32.of_int_s !memory_alloc_size));
       Call "caml_alloc";
       SetLocal alloc_memory_pointer
      ]
      in
      let set_blocks = ref [] in
      let get_blocks = ref [] in
      let memory_block_position = ref 4 in (* first block is reserved for the return value *)
      VarMap.iter (fun _ (value, t) ->
        set_blocks := !set_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> (
                [GetLocal value;
                 Store {ty = I32Type; align = 0; offset = 0l; sz = None}]
              )
            | F32Type -> (
                [GetLocal value;
                 Store {ty = F32Type; align = 0; offset = 0l; sz = None}]
              )
            | _ -> failwith "not supported"
          );
        get_blocks := !get_blocks @ [
          GetLocal alloc_memory_pointer;
          Const (I32 (I32.of_int_s !memory_block_position));
          Binary (I32 I32Op.Add)] @
          ( match t with
            | I32Type -> [Load {ty = I32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | F32Type -> [Load {ty = F32Type; align = 0; offset = 0l; sz = None}; SetLocal value]
            | _ -> failwith "not supported"
          );
        (* match t with
          | I32Type
          | F32Type -> ( *)
          memory_block_position := !memory_block_position + 4;
            (* ) *)
          (* | _ -> assert false *)
      ) context.locals.l_map;
      let body_fn_id = create_exception_function context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_body") body in
      let exn_name = (exn.Ident.name ^ "_" ^ string_of_int exn.Ident.stamp) in
      let handler_fn_id = create_exception_function ~is_handler:true ~exn_name context alloc_memory_pointer (exn.Ident.name ^ "_" ^ (string_of_int exn.Ident.stamp) ^ "_handler") handler in
      
      current_return_type := [I32Type];
      !store_instructions @
      !set_blocks @
      [
      GetLocal alloc_memory_pointer;
      Const (I32 body_fn_id);
      Const (I32 handler_fn_id);
      Call "caml_alloc"] @
      !get_blocks @
      [ GetLocal alloc_memory_pointer;
        Load {ty = I32Type; align = 0; offset = 0l; sz = None}; (* TODO: also support float return value... *)
      ] *)
    )




let begin_assembly () = (
  let globals = [{
    name = "global_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s !global_offset))]
  };
  {
    name = "global_memory_offset";
    gtype = Types.GlobalType (Types.I32Type, Types.Mutable);
    value = [Const (I32 (I32.of_int_s 0))]
  }
  ]
  in
  let data = [{
    index =  0l;
    offset = [Const (I32 0l)];
    init = {
      name = "caml_globals_inited";
      detail = [Int8 0]
    };
  }; {
    index =  0l;
    offset = [Const (I32 1l)];
    init = {
      name = "caml_backtrace_pos";
      detail = [Int32 0l]
    };
  };
  ]
  in
  
  let w = !wasm_module in
  wasm_module := {w with symbols = w.symbols @ [{
    name = "caml_globals_inited";
    details = Data ({
      index = 0l;
      relocation_offset = 0l;
      size =  1l;
      offset = 0l;
    })
  };
  {
    name = "caml_backtrace_pos";
    details = Data ({      
      index = 1l;
      relocation_offset = 0l;
      size =  4l;
      offset = 1l;
    })
  };
  ]};

  global_offset := !global_offset + 5; (* TODO: make this a bit smarter (eg. count the previous sizes) *)

  let jsTryWithType:Ast.type_ = {name = "jsTryWithType"; details = Types.FuncType ([Types.I32Type;Types.I32Type;Types.I32Type], [])} in
  let type_:Ast.type_ = {name = "type_"; details = Types.FuncType ([Types.I32Type], [Types.I32Type])} in
  let empty_type:Ast.type_ = {name = "empty_type"; details = Types.FuncType ([], [])} in
  let raise_i32_unit:Ast.type_ = {name = "raise_i32_ftype"; details = Types.FuncType ([Types.I32Type], [])} in
  let types = [ jsTryWithType; type_; empty_type; raise_i32_unit] in
  
  let imports = [
    {
      module_name = name "js";
      item_name = name "tryWith";
      idesc = FuncImport "jsTryWithType"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_i32";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "js";
      item_name = name "jsRaise_i32_unit";
      idesc = FuncImport "raise_i32_ftype"
    };
    {
      module_name = name "js";
      item_name = name "caml_fresh_oo_id";
      idesc = FuncImport "type_"
    };
    {
      module_name = name "libasmrun";
      item_name = name "caml_alloc";
      idesc = FuncImport "type_"
    };
    (* {
      module_name = name "linking";
      item_name = name "camlCamlinternalFormatBasics__entry";
      idesc = FuncImport "empty_type"
    }; *)
    {
      module_name = name "linking";
      item_name = name "camlPervasives__entry";
      idesc = FuncImport "empty_type"
    };
  ]
  in

  
  create_import_symbol "jsTryWith" [] [];
  create_import_symbol "jsRaise_i32_i32" [] [];
  create_import_symbol "jsRaise_i32_unit" [] [];
  create_import_symbol "caml_fresh_oo_id" [] [];
  create_import_symbol "caml_alloc" [] [];
  (* create_import_symbol "camlCamlinternalFormatBasics__entry" [||]; *)
  create_import_symbol "camlPervasives__entry" [] [];

  let exports = [
  {
    name = name "table";
    edesc = TableExport 0l;
  };
  {
    name = name "memory";
    edesc = MemoryExport 0l;
  }
  ]
  in
  let w = !wasm_module in
  wasm_module := Ast.{w with
    globals = globals;
    types = types;
    data = data;
    imports = imports;
    exports = exports;
  };
)

(* let rec add_exception_functions ppf = (
  let _exception_fns = !exception_fns in
  exception_fns := [];
  List.iter (fun {name; expression; mem_pointer; locals; is_handler; exn_name} -> (
    let exn_name = match exn_name with
    | Some s -> s
    | _ -> ""
    in
    compile_wasm_phrase  ~locals ~is_handler ~exn_name ppf (Cfunction ({
      fun_name = name;
      fun_args = [];
      fun_body = expression;
      fun_codegen_options = [];
      fun_dbg = []
      }))
    )) _exception_fns;

) *)

let fundecl ({fun_name; fun_args; fun_body; _}) = (  
    let context = enter_func () in
    let args = ref [] in
    List.iter (fun (ident, mt) ->
      let value_type = match mt with
      | [|Val|]
      | [|Addr|]
      | [|Int|] -> I32Type
      | [|Float|] -> F32Type
      | _ -> failwith "Unexpected combination of machtypes"
      in
      ignore(bind_local context (ident.Ident.name ^ "_" ^ string_of_int ident.Ident.stamp) value_type);
      args := [Types.I32Type] @ !args;      
    ) (List.rev fun_args);

    (* print_string (fun_name ^ " - ");

    List.iter Ident.(fun (ident, mt) ->
      print_string (" @" ^ ident.name ^ ":");
      match mt with
      | [|Val|] -> print_string "val"
      | [|Addr|] -> print_string "addr"
      | [|Int|] -> print_string "int"
      | [|Float|] -> print_string "float"
      | _ -> failwith "Unexpected combination of machtypes"
    ) fun_args; *)
    
    create_func_symbol fun_name (0, 0);
    
    (* remove unit return value *)
    let rec remove_last_unit fun_body =
      match fun_body with            
      | Csequence (expr, Cconst_int 1) -> expr
      | Csequence (expr1, Csequence (a, b)) -> Csequence (expr1, remove_last_unit (Csequence (a, b)))
      | _ as e -> e
    in
    let fun_body = remove_last_unit fun_body in    
    let fun_body = emit_expr context fun_body in     
    let body = fun_body in
    let type_:Ast.type_ = {name = fun_name; details = Types.FuncType (!args, !current_return_type)} in
    let temp_locals = ref [] in
    VarMap.iter (fun _ (i, t, name) -> 
      temp_locals := !temp_locals @ [(i, name, t)]
    ) context.locals.l_map;
    let temp_locals = List.sort (fun (a, _, _) (b, _,_) -> 
      if (I32.gt_u a b) then 
        1 
      else if (I32.lt_u b a) then
        -1 
      else 
        0
    ) !temp_locals in
    let locals = List.map (fun (_, name, t) -> (name, t)) temp_locals in
    let result = {
      name = fun_name;
      ftype = fun_name;
      locals = locals;
      body;
    } in
    let export = {
      name = name fun_name;
      edesc = FuncExport fun_name;
    } in

    let w = !wasm_module in
    wasm_module := Ast.{w with funcs = w.funcs @ [result];
                               types = w.types @ [type_];
                               exports = w.exports @ [export];
                               };
)
and data dl = (
    if List.length dl > 0 then (        
        let init = ref [] in
        let start_offset = !global_offset in
        (* let data_id = ref 0l in *)
        let offset = ref 0 in        
        let symbol_name = ref "" in
        let size = ref 0n in
        let is_closure =
            match List.hd dl with
            | Cint i when (((Nativeint.to_int i) land 255) == 247) -> 
              let (s, _) = blockheader_details i in
              size := s;
              true
            | Csymbol_address _ -> true
            | _ -> false
        in
        List.iter (function
        | Cglobal_symbol _ -> ()
        | Csymbol_address symbol -> (            
            let add =
              if is_closure then               
                ((if not (func_symbol_exists symbol) then (                  
                  create_import_symbol symbol [] [];
                  [FunctionLoc symbol] 
                  )
                  else 
                    [FunctionLoc symbol]
                  )
                )
              else  
                
                [Symbol symbol]
            in
            init := !init @ add;
            offset := !offset + 4;
            ()
            )
        | Cdefine_symbol symbol -> 
          symbol_name := symbol
        | Cint8 i -> (
            init := !init @ [Int8 i];
            offset := !offset + 1;
            ()
            )
        | Cint16 i -> (
            init := !init @ [Int16 i];
            offset := !offset + 2;
            ()
            )
        | Cint32 ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Cint ni -> (
            init := !init @ [Nativeint ni];
            offset := !offset + 4;
            ()
            )
        | Csingle d
        | Cdouble d -> (
            init := !init @ [Float32 (F32.of_float d)];
            offset := !offset + 4;
            ()
            )
        | Cstring s -> (
            init := !init @ [Ast.String s];
            offset := !offset + (String.length s);
            ()
            )
        | Cskip _ -> ()
        | Calign _ -> () (* seems not to be produced anyway in the OCaml codebase *)
        ) dl;

        let w = !wasm_module in
        wasm_module := {w with symbols = w.symbols @ [{
          name = !symbol_name;
          details = Data ({
              index = 0l;
              relocation_offset = 0l;
              size =  Int32.of_int !offset;
              offset = Int32.of_int start_offset
          })
        }]};
        
        let w = !wasm_module in

        global_offset := !global_offset + !offset;

        (* to make sure that this is always seen as data and not an integer *)
        (if !global_offset land 1 <> 0 then global_offset := !global_offset + 1);
        wasm_module := Ast.{w with data = w.data @ [{
        index =  0l;
        offset = [Const (I32 (I32.of_int_s start_offset))];
        init = {
            name = !symbol_name;
            detail = !init
        }
        }];
    }
    )
)